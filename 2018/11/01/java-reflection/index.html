<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Java反射和注解反射机制Java反射机制指的是在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任何一个对象，都能够调用它的任意一个方法和属性。这种 动态地获取信息 以及 动态调用对象的方法 的功能称为java的反射机制。  反射机制可以让你在程序运行时，拿到任意一个类的属性和方法并调用它。">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java反射和注解">
<meta property="og:url" content="http://flyen.github.io/2018/11/01/java-reflection/index.html">
<meta property="og:site_name" content="flyEn&#39;blog">
<meta property="og:description" content="Java反射和注解反射机制Java反射机制指的是在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任何一个对象，都能够调用它的任意一个方法和属性。这种 动态地获取信息 以及 动态调用对象的方法 的功能称为java的反射机制。  反射机制可以让你在程序运行时，拿到任意一个类的属性和方法并调用它。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-11-03T02:57:15.811Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java反射和注解">
<meta name="twitter:description" content="Java反射和注解反射机制Java反射机制指的是在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任何一个对象，都能够调用它的任意一个方法和属性。这种 动态地获取信息 以及 动态调用对象的方法 的功能称为java的反射机制。  反射机制可以让你在程序运行时，拿到任意一个类的属性和方法并调用它。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://flyen.github.io/2018/11/01/java-reflection/"/>





  <title> Java反射和注解 | flyEn'blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">flyEn'blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://flyen.github.io/2018/11/01/java-reflection/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Iwhale">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="flyEn'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="flyEn'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java反射和注解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-01T10:11:52+08:00">
                2018-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java反射和注解"><a href="#Java反射和注解" class="headerlink" title="Java反射和注解"></a>Java反射和注解</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>Java反射机制指的是在<u>程序运行状态</u>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任何一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态地获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为<strong>java的反射机制</strong>。</p>
<blockquote>
<p>反射机制可以让你在程序运行时，拿到任意一个类的属性和方法并调用它。</p>
</blockquote>
<a id="more"></a>
<h3 id="为什么要用反射机制？"><a href="#为什么要用反射机制？" class="headerlink" title="为什么要用反射机制？"></a>为什么要用反射机制？</h3><p>首先，需要理解一下动态与静态的概念。</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象，即通过。</li>
<li>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的耦合性。</li>
</ul>
<p><strong>优点</strong></p>
<p>可以实现动态创建对象和编译，体现出很大的灵活性。</p>
<p><strong>缺点</strong></p>
<p>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</p>
<h3 id="理解Class类和类的类型"><a href="#理解Class类和类的类型" class="headerlink" title="理解Class类和类的类型"></a>理解Class类和类的类型</h3><p>首先理解一下Class类，它是反射实现的基础。</p>
<p>类是java.lang.Class类的实例对象，而Class是所有类的类。</p>
<p>对于普通的对象，我们一般都会这样创建和表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code code = <span class="keyword">new</span> Code();</span><br></pre></td></tr></table></figure>
<p>既然所有的类都是Class的对象，那该如何表示呢，可不可以通过如下方式呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = <span class="keyword">new</span> Class()</span><br></pre></td></tr></table></figure>
<p>但是我们查看Class的源码时，是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123; </span><br><span class="line">    classLoader = loader; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到构造器是私有的，只有JVM可以创建Class的对象，因此不可以像普通类一样new一个Class对象，虽然我们不能new一个Class对象，但是却可以通过已有的类得到一个Clas对象，有三种方式，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Code.class;</span><br><span class="line"><span class="comment">// 这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的</span></span><br><span class="line">Class c2 = code1.getClass();</span><br><span class="line"><span class="comment">// code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的</span></span><br><span class="line">Class c3 = Class.forName(<span class="string">"com.trigl.reflect.Code"</span>);</span><br><span class="line"><span class="comment">// 这种方法是Class类调用forName方法，通过一个类的全量限定名获得</span></span><br></pre></td></tr></table></figure>
<p>这里，c1、c2、c3都是Class的对象，他们是完全一样的，而且有个学名，叫做Code的类类型（class type）。<br>这里就让人奇怪了，前面不是说Code是Class的对象吗，而c1、c2、c3也是Class的对象，那么Code和c1、c2、c3不就一样了吗？为什么还叫Code什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//第一种：Class c1 = Code.class;</span></span><br><span class="line">        Class class1=ReflectDemo.class;</span><br><span class="line">        System.out.println(class1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种：Class c2 = code1.getClass();</span></span><br><span class="line">        ReflectDemo demo2= <span class="keyword">new</span> ReflectDemo();</span><br><span class="line">        Class c2 = demo2.getClass();</span><br><span class="line">        System.out.println(c2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种：Class c3 = Class.forName("com.trigl.reflect.Code");</span></span><br><span class="line">        Class class3 = Class.forName(<span class="string">"com.tengj.reflect.ReflectDemo"</span>);</span><br><span class="line">        System.out.println(class3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br></pre></td></tr></table></figure>
<h3 id="java反射的主要功能"><a href="#java反射的主要功能" class="headerlink" title="java反射的主要功能"></a>java反射的主要功能</h3><ul>
<li>运行时构造一个类的对象</li>
<li>运行时获取一个类所具有的成员变量和方法</li>
<li>运行时调用任意一个对象的方法</li>
<li>生成动态代理</li>
</ul>
<h3 id="反射的相关操作"><a href="#反射的相关操作" class="headerlink" title="反射的相关操作"></a>反射的相关操作</h3><p>前面我们说到了如何拿到一个类的Class信息，那用这个Class可以获取那些信息呢？</p>
<ul>
<li><p>获取/操作类的构造函数</p>
</li>
<li><p>获取/操作类的成员变量</p>
</li>
<li>获取/操作类的成员方法</li>
</ul>
<h4 id="获取类的构造函数"><a href="#获取类的构造函数" class="headerlink" title="获取类的构造函数"></a>获取类的构造函数</h4><p>其实，类的构造函数是java.lang.reflect.Constructor类的对象，通过Class的下列方法可以获取构造函数对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="comment">//  获得该类所有的构造器，不包括其父类的构造器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 获得该类所有public构造器，包括父类</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//具体</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] allConstructors </span>= class1.getDeclaredConstructors();<span class="comment">//获取class对象的所有声明构造函数 </span></span><br><span class="line">Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();<span class="comment">//获取class对象public构造函数 </span></span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);<span class="comment">//获取指定声明构造函数（局部变量是一个字符串类型的） </span></span><br><span class="line">Constructor publicConstructor = class1.getConstructor(String.class);<span class="comment">//获取指定声明的public构造函数</span></span><br></pre></td></tr></table></figure>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;?&gt; personClass = Class.forName(<span class="string">"com.catchu.me.reflect.Person"</span>);</span><br><span class="line">        <span class="comment">//获取所有的构造函数，包括私有的，不包括父类的</span></span><br><span class="line">        Constructor&lt;?&gt;[] allConstructors = personClass.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">//获取所有公有的构造函数，包括父类的</span></span><br><span class="line">        Constructor&lt;?&gt;[] publicConstructors = personClass.getConstructors();</span><br><span class="line">        System.out.println(<span class="string">"遍历之后的构造函数："</span>);</span><br><span class="line">        <span class="keyword">for</span>(Constructor c1 : allConstructors)&#123;</span><br><span class="line">            System.out.println(c1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; c2 = personClass.getDeclaredConstructor(String.class);</span><br><span class="line">        c2.setAccessible(<span class="keyword">true</span>); <span class="comment">//设置是否可访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不用设置</span></span><br><span class="line">        Object person = c2.newInstance(<span class="string">"刘俊重"</span>);   <span class="comment">//使用反射创建Person类的对象,并传入参数</span></span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类如下，为测出效果包含一个私有构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//省略set/get方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">遍历之后的构造函数：</span><br><span class="line"><span class="keyword">public</span> com.catchu.me.reflect.Person(<span class="keyword">int</span>,java.lang.String)</span><br><span class="line"><span class="keyword">private</span> com.catchu.me.reflect.Person(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> com.catchu.me.reflect.Person()</span><br><span class="line">Person&#123;age=<span class="number">0</span>, name=<span class="string">'刘俊重'</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由上面可以看到我们在获得某个类的Class类类型之后，可以通过反射包中的方法获取到这个类的构造函数，进而可以创建该类的对象。</p>
</blockquote>
<h4 id="获取类的成员变量"><a href="#获取类的成员变量" class="headerlink" title="获取类的成员变量"></a>获取类的成员变量</h4><p>成员变量里包括：成员变量类型+成员变量名</p>
<p>其实，类的成员变量也是一个对象，它是<code>java.lang.reflect.Field</code>的一个对象，所以我们可以通过<code>java.lang.reflect.Field</code>里封装的方法来获取这些信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> <span class="comment">// 获得该类自身声明的所有变量，不包括其父类的变量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span> <span class="comment">// 获得该类自所有的public成员变量，包括其父类变量</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//具体实现</span></span></span><br><span class="line"><span class="function">Field[] allFields </span>= class1.getDeclaredFields();<span class="comment">//获取class对象的所有属性 </span></span><br><span class="line">Field[] publicFields = class1.getFields();<span class="comment">//获取class对象的public属性 </span></span><br><span class="line">Field ageField = class1.getDeclaredField(<span class="string">"age"</span>);<span class="comment">//获取class指定属性 </span></span><br><span class="line">Field desField = class1.getField(<span class="string">"des"</span>);<span class="comment">//获取class指定的public属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数是成员变量所定义的名字。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">        <span class="comment">//获取所有的成员变量，包含私有的</span></span><br><span class="line">        Field[] allFields = personClass.getDeclaredFields();</span><br><span class="line">        <span class="comment">//获取所有公有的成员变量，包含父类的</span></span><br><span class="line">        Field[] publicFields = personClass.getFields();</span><br><span class="line">        System.out.println(<span class="string">"所有的成员变量："</span>);</span><br><span class="line">        <span class="keyword">for</span>(Field f : allFields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//获取某个变量的值</span></span><br><span class="line">        <span class="comment">//创建对象的实例</span></span><br><span class="line">        Constructor&lt;Person&gt; c = personClass.getDeclaredConstructor(String.class);</span><br><span class="line">        c.setAccessible(<span class="keyword">true</span>); <span class="comment">//因为该构造函数时私有的，需要在这里设置成可访问的</span></span><br><span class="line">        Person person = c.newInstance(<span class="string">"刘俊重"</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//获取变量name对象</span></span><br><span class="line">        Field field = personClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>); <span class="comment">//因为变量name是私有的，需要在这里设置成可访问的</span></span><br><span class="line">        <span class="comment">//注意对比下面这两行，官方对field.get(Object obj)方法的解释是返回对象obj字段field的值</span></span><br><span class="line">        Object value = field.get(person);</span><br><span class="line">        <span class="comment">//String name = person.getName();</span></span><br><span class="line">        System.out.println(<span class="string">"获取的变量的值是："</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">所有的成员变量：</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> com.catchu.me.reflect.Person.age</span><br><span class="line"><span class="keyword">private</span> java.lang.String com.catchu.me.reflect.Person.name</span><br><span class="line">获取的变量的值是：刘俊重</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要注意field.get(person)方法，我们根据对象获取属性的常规方法是通过：String name = person.getName()，反射中可以通过：字段.get(对象)，这也是获取对象的某个字段，有点类似于invoke方法。</p>
</blockquote>
<h4 id="获取类的成员方法"><a href="#获取类的成员方法" class="headerlink" title="获取类的成员方法"></a>获取类的成员方法</h4><p>万物皆对象，类的成员方法是java.lang.reflect.Method的对象，通过java.lang.Class类的以下方法可以获取到类的成员方法，通过方法类Method提供的一些方法，又可以调用获取到的成员方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 得到该类所有的方法，不包括父类的 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 得到该类所有的public方法，包括父类的</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//具体使用</span></span></span><br><span class="line"><span class="function">Method[] methods </span>= class1.getDeclaredMethods();<span class="comment">//获取class对象的所有声明方法 </span></span><br><span class="line">Method[] allMethods = class1.getMethods();<span class="comment">//获取class对象的所有public方法 包括父类的方法 </span></span><br><span class="line">Method method = class1.getMethod(<span class="string">"info"</span>, String.class);<span class="comment">//返回此class1对应的public修饰的方法名是info的，包含一个String类型变量的方法</span></span><br><span class="line">Method declaredMethod = class1.getDeclaredMethod(<span class="string">"info"</span>, String.class);<span class="comment">//返回此Class对象对应类的、带指定形参列表的方法</span></span><br></pre></td></tr></table></figure>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Class&lt;? extends Person&gt; personClass = person.getClass();</span><br><span class="line">        Method[] allMethods = personClass.getDeclaredMethods();</span><br><span class="line">        Method[] publicMethods = personClass.getMethods();</span><br><span class="line">        System.out.println(<span class="string">"遍历所有的方法："</span>);</span><br><span class="line">        <span class="keyword">for</span>(Method m : allMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是测试通过反射调用函数</span></span><br><span class="line">        <span class="comment">//通过反射创建实例对象,默认调无参构造函数</span></span><br><span class="line">        Person person2 = personClass.newInstance();</span><br><span class="line">        <span class="comment">//获取要调用的方法,要调用study方法，包含int和String参数，注意int和Integer在这有区别</span></span><br><span class="line">        Method method = personClass.getMethod(<span class="string">"study"</span>, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">        Object o = method.invoke(person2, <span class="number">18</span>, <span class="string">"刘俊重"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">遍历所有的方法：</span><br><span class="line"><span class="keyword">public</span> java.lang.String com.catchu.me.reflect.Person.toString()</span><br><span class="line"><span class="keyword">public</span> java.lang.String com.catchu.me.reflect.Person.getName()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> com.catchu.me.reflect.Person.setName(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> com.catchu.me.reflect.Person.study(<span class="keyword">int</span>,java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> com.catchu.me.reflect.Person.getAge()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> com.catchu.me.reflect.Person.setAge(<span class="keyword">int</span>)</span><br><span class="line">我叫刘俊重,我今年<span class="number">18</span>,我在学习反射</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Object o = method.invoke(person2, 18, “刘俊重”);就是调用person2对象的method方法，格式是：方法名.invoke(对象,参数),类似于获取成员变量值时的get方法。</p>
</blockquote>
<p>由上面可以看出反射的强大：通过反射我们可以获取到类类型，通过Class类型我们可以获取到构造函数，进而实例化new出一个对象；通过反射我们可以获取到成员变量和成员方法，通过实例出的对象又可以获取到这些成员变量的值或调用成员方法。这才只是反射的一部分，通过反射我们还可以判断类，变量，方法，<strong>是否包含某些特定注解</strong>，还可以<strong>通过反射来动态代理去调用其它方法</strong>，跟注解和动态代理挂起勾会有无限的想象空间，比如spring框架，<u>底层就是通过这些原理</u>。下面在说几个反射常用的API，最后会介绍反射跟注解和动态代理的结合使用。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>1.注解中常用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = (Annotation[]) class1.getAnnotations();<span class="comment">//获取class对象的所有注解 </span></span><br><span class="line">Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);<span class="comment">//获取class对象指定注解 </span></span><br><span class="line">Type genericSuperclass = class1.getGenericSuperclass();<span class="comment">//获取class对象的直接超类的 </span></span><br><span class="line">Type Type[] interfaceTypes = class1.getGenericInterfaces();<span class="comment">//获取class对象的所有接口的type集合</span></span><br></pre></td></tr></table></figure>
<p>2.获取Class对象其他信息的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isPrimitive = class1.isPrimitive();<span class="comment">//判断是否是基础类型 </span></span><br><span class="line"><span class="keyword">boolean</span> isArray = class1.isArray();<span class="comment">//判断是否是集合类</span></span><br><span class="line"><span class="keyword">boolean</span> isAnnotation = class1.isAnnotation();<span class="comment">//判断是否是注解类 </span></span><br><span class="line"><span class="keyword">boolean</span> isInterface = class1.isInterface();<span class="comment">//判断是否是接口类 </span></span><br><span class="line"><span class="keyword">boolean</span> isEnum = class1.isEnum();<span class="comment">//判断是否是枚举类 </span></span><br><span class="line"><span class="keyword">boolean</span> isAnonymousClass = class1.isAnonymousClass();<span class="comment">//判断是否是匿名内部类 </span></span><br><span class="line"><span class="keyword">boolean</span> isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);<span class="comment">//判断是否被某个注解类修饰 </span></span><br><span class="line">String className = class1.getName();<span class="comment">//获取class名字 包含包名路径 </span></span><br><span class="line">Package aPackage = class1.getPackage();<span class="comment">//获取class的包信息 </span></span><br><span class="line">String simpleName = class1.getSimpleName();<span class="comment">//获取class类名 </span></span><br><span class="line"><span class="keyword">int</span> modifiers = class1.getModifiers();<span class="comment">//获取class访问权限 </span></span><br><span class="line">Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();<span class="comment">//内部类 </span></span><br><span class="line">Class&lt;?&gt; declaringClass = class1.getDeclaringClass();<span class="comment">//外部类</span></span><br><span class="line">ClassLoader ClassLoader = class1.getClassLoader() 返回类加载器</span><br><span class="line"></span><br><span class="line">getSuperclass()：获取某类所有的父类  </span><br><span class="line">getInterfaces()：获取某类所有实现的接口</span><br></pre></td></tr></table></figure>
<h3 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h3><p>Java中集合的泛型，是防止错误输入的，<strong>只在编译阶段有效</strong>，绕过编译到了运行期就无效了。</p>
<p>验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合泛型的本质</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Trigl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016年4月2日上午2:54:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEssence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list1 = <span class="keyword">new</span> ArrayList(); <span class="comment">// 没有泛型 </span></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 有泛型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.首先观察正常添加元素方式，在编译器检查泛型，</span></span><br><span class="line"><span class="comment">         * 这个时候如果list2添加int类型会报错</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list2.add(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//      list2.add(20); // 报错！list2有泛型限制，只能添加String，添加int报错</span></span><br><span class="line">        System.out.println(<span class="string">"list2的长度是："</span> + list2.size()); <span class="comment">// 此时list2长度为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2</span></span><br><span class="line"><span class="comment">         * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int</span></span><br><span class="line"><span class="comment">         * 型的元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class c1 = list1.getClass();</span><br><span class="line">        Class c2 = list2.getClass();</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">// 结果：true，说明类类型完全相同</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = c2.getMethod(<span class="string">"add"</span>, Object.class); <span class="comment">// 通过方法反射得到add方法</span></span><br><span class="line">            m.invoke(list2, <span class="number">20</span>); <span class="comment">// 给list2添加一个int型的，上面显示在编译器是会报错的</span></span><br><span class="line">            System.out.println(<span class="string">"list2的长度是："</span> + list2.size()); <span class="comment">// 结果：2，说明list2长度增加了，并没有泛型检查</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入</span></span><br><span class="line"><span class="comment">         * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>代理的操作是通过java.lang.reflect.Proxy 类中实现的，通过<strong>Proxy</strong>的<code>newProxyInstance()</code>方法可以创建一个代理对象，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<p>从中，可以看到需要三个参数，<u>类加载器，接口和调用处理者</u>。我们在上面已经能拿到Class类了，使用class.getClassLoader就可以获取类加载器，使用class.getgetInterfaces()可以获取所有的接口，那现在要写的不就是新建一个InvocationHandler对象了吗？事实上，我们动态代理的核心代码也就是在这里面写的。我上面说的模板，其实就是下面这几步：</p>
<ol>
<li><p>书写代理类和代理方法，在代理方法中实现代理<code>Proxy.newProxyInstance()</code>;</p>
</li>
<li><p>代理中需要的参数分别为：被代理的类的类加载器<code>class.getClassLoader()</code>，被代理类的所有实现接口<code>new Class[] { Interface.class }</code>，句柄方法<code>new InvocationHandler()</code>;</p>
</li>
<li><p>在句柄方法中重写<strong>invoke</strong>方法，invoke方法的输入有3个参数<u>Object proxy（代理类对象）, Method method（被代理类的方法）,Object[] args（被代理类方法的传入参数）</u>，在这个方法中，我们可以定制化的写我们的业务；</p>
</li>
<li><p>获取代理类，强转成被代理的接口；</p>
</li>
<li><p>最后，我们可以像没被代理一样，调用接口的任何方法，方法被调用后，方法名和参数列表将被传入代理类的invoke方法中，进行新业务的逻辑流程。</p>
<p>看下面的示例代码： 接口PersonInterface：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人类在做事"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人类在说话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘俊重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PersonImpl person = <span class="keyword">new</span> PersonImpl();</span><br><span class="line">        PersonInterface proxyPerson = (PersonInterface) Proxy.newProxyInstance(PersonImpl.class.getClassLoader(),</span><br><span class="line">                PersonImpl.class.getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">//在下面的invoke方法里面写我们的业务</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(method.getName()==<span class="string">"doSomething"</span>)&#123;</span><br><span class="line">                            person.doSomething();</span><br><span class="line">                            System.out.println(<span class="string">"通过常规方法调用了实现类"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            method.invoke(person,args);</span><br><span class="line">                            System.out.println(<span class="string">"通过反射机制调用了实现类"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyPerson.doSomething();</span><br><span class="line">        proxyPerson.saySomething();</span><br><span class="line">        <span class="comment">// 执行结果：</span></span><br><span class="line">      	<span class="comment">// 人类在做事</span></span><br><span class="line">				<span class="comment">// 通过常规方法调用了实现类</span></span><br><span class="line">				<span class="comment">// 人类在说话</span></span><br><span class="line">				<span class="comment">// 通过反射机制调用了实现类</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们通过<code>proxyPerson.doSomething()</code>调用的时候，其实不是立马进入实现类的doSomething方法，而是带着方法名，参数进入到了我们的代理方法invoke里面，在这里面我进行了一次判断，如果等于”doSomething”就使用常规方法调用，否则使用反射的方法调用。这样看似还是平时的调用，但是每次执行都要走我们的代理方法里面，我们可以在这里面做些“手脚”，<u>加入我们的业务处理</u>。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>注解即元数据，就是源代码的元数据。</li>
</ul>
<blockquote>
<p>元数据是指用来描述数据的数据，更通俗一点，就是描述代码间关系，或者代码与其他资源（例如数据库表）之间内在联系的数据。</p>
</blockquote>
<ul>
<li>注解在代码中添加信息提供了一种形式化的方法，可以在后续中更方便地使用这些数据。</li>
<li><strong>Annotation</strong>是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。它是一种由JSR-175标准选择用来描述<strong>元数据</strong>的一种工具。</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>生成文档</li>
<li>跟踪代码依赖性，实现替代配置文件功能，减少配置。如Spring中的一些注解。</li>
<li>在编译时进行格式检验，如@Override等</li>
<li>每当你创建描述符性质的类或者接口时，一旦其中<u>包含重复性的工作</u>，就可以考虑使用注解来简化与自动化该过程。</li>
</ul>
<h3 id="java注解"><a href="#java注解" class="headerlink" title="java注解"></a>java注解</h3><p>什么是java注解？ 在java语法中，使用@符号作为开头，并在@后面紧跟注解名。被运用于类，接口，方法和字段之上，java中的注解包是java.lang.annotation，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123; </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中@Override就是注解。这个注解的作用也就是告诉编译器，myMethod()方法覆盖了父类中的myMethod()方法。</p>
<p><strong>java中内置的注解</strong>：</p>
<ol>
<li>@Override:表示当前的方法定义将覆盖超类中的方法，如果出现错误，编译器就会报错。</li>
<li>@Deprecated:如果使用此注解，编译器会出现警告信息。 </li>
<li>@SuppressWarnings:忽略编译器的警告信息。</li>
</ol>
<h4 id="java注解类反编译"><a href="#java注解类反编译" class="headerlink" title="java注解类反编译"></a>java注解类反编译</h4><p>java中的类、接口、枚举、注解都可以看做是类类型。如果利用JAD反编译工具来看@interface被转换成什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Foo&#123;</span><br><span class="line">  String[] value();</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看反编译代码可以看出：</p>
<ul>
<li>自定义的注解类Foo被转换成接口Foo，并且继承Annotation接口</li>
<li>原来自定义接口中的value()和bar()被转换成抽象方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Annotation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解通常和反射配合使用，而且既然自定义的注解最终被转换成接口，注解中的属性被转换成接口中的抽象方法，那么通过反射之后拿到接口实例，在通过接口实例自然能够调用对应的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span>(value=&#123;<span class="string">"sherman"</span>, <span class="string">"decompiler"</span>&#125;, bar=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Foo foo = Demo.class.getAnnotation(Foo.class);</span><br><span class="line">        System.out.println(Arrays.toString(foo.value())); <span class="comment">// [sherman, decompiler]</span></span><br><span class="line">        System.out.println(foo.bar());                    <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>元注解：</strong> </p>
<p>元注解的作用就是<u>负责注解其他注解</u>（自定义注解的时候用到的）。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。 </p>
<p>Java5.0定义的4个元注解：<code>@Target</code>、<code>@Retention</code>、<code>@Documented</code>、<code>@Inherited</code>。</p>
<blockquote>
<p>java8加了两个新注解</p>
</blockquote>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><blockquote>
<p>@Target说明了Annotation<strong>所修饰的对象范围</strong>：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。</p>
</blockquote>
<p>作用：<strong>用于描述注解的使用范围</strong>。（即：<u>被描述的注解可以用在什么地方</u>）</p>
<p>取值（ElementType）有：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTRUCTOR</td>
<td style="text-align:left">用于描述构造器</td>
</tr>
<tr>
<td>FIELD</td>
<td style="text-align:left">用于描述域</td>
</tr>
<tr>
<td>LOCAL_VARIABLE</td>
<td style="text-align:left">用于描述局部变量</td>
</tr>
<tr>
<td>METHOD</td>
<td style="text-align:left">用于描述方法</td>
</tr>
<tr>
<td>PACKAGE</td>
<td style="text-align:left">用于描述包</td>
</tr>
<tr>
<td>PARAMETER</td>
<td style="text-align:left">用于描述参数</td>
</tr>
<tr>
<td>TYPE</td>
<td style="text-align:left">用于描述类、接口(包括注解类型) 或enum声明</td>
</tr>
</tbody>
</table>
<p>比如定义下面一个注解，它就只能用在方法上，因为已经限定了它是方法级别的注解，如果用在类或者其它上面，编译阶段就会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMethodAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><blockquote>
<p>@Retention定义了该Annotation<strong>被保留的时间长短</strong>：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p>
</blockquote>
<p>作用：<strong>表示需要在什么级别保存该注释信息</strong>，用于描述注解的生命周期（即：<u>被描述的注解在什么范围内有效</u>）</p>
<p>取值有：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOURCE</td>
<td>在源文件中有效（即源文件保留）</td>
<td>仅出现在源代码中，而被编译器丢弃</td>
</tr>
<tr>
<td>CLASS</td>
<td>在class文件中有效（即class文件保留）</td>
<td>被编译在class文件中</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>在运行时有效（即运行时保留）</td>
<td>编译在class文件中</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)  <span class="comment">//用在描述类、接口或enum</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  <span class="comment">//运行时有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyClassAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;  <span class="comment">//这个MyClassAnnotation注解有个value属性，将来可以设置/获取值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><blockquote>
<p>@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p>
</blockquote>
<p>作用：是在生成javadoc文档的时候将该Annotation也写入到文档中。即<strong>将注解写入在javadoc中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.annotation.Documented</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyCustomAnnotation &#123; <span class="comment">//Annotation body&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><blockquote>
<p>是一个<strong>标记注解</strong>，阐述了某个<strong>被标注的类型是被继承的</strong>，使用了@Inherited修饰的annotation类型<u>被用于一个class</u>,则这个annotation将被用于该class的子类，@Inherited annotation类型是被标注过的class的子类所继承。类并不从实现的接口继承annotation,方法不从它所重载的方法继承annotation，当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>
</blockquote>
<p>作用：<strong>允许子类继承父类中的注解。</strong></p>
<p>示例，这里的MyParentClass 使用的注解标注了@Inherited，所以子类可以继承这个注解信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.annotation.Inherited</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyCustomAnnotation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyCustomAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParentClass</span> </span>&#123; </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChildClass</span> <span class="keyword">extends</span> <span class="title">MyParentClass</span> </span>&#123; </span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK提供的几个基本注解：</p>
<ol>
<li>@SuppressWarnings：阻止编译器发出某些警告信息。</li>
<li>@Deprecated：标记某个过时的类或方法</li>
<li>@Override：用在方法面前，用来标识该方法是重写父类的某个方法。</li>
</ol>
</blockquote>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">  定义体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解参数的可支持数据类型</strong>：</p>
<ul>
<li>所有基本数据类型(int,float,double,boolean,byte,char,long,short)</li>
<li>String类型</li>
<li>Class类型</li>
<li>enum类型</li>
<li>Annotation类型</li>
<li>以上所有类型的数组</li>
</ul>
<p><strong>规则</strong>：</p>
<ul>
<li>修饰符只能是public 或默认(default)</li>
<li>参数成员只能用基本类型byte,short,int,long,float,double,boolean八种基本类型和String,Enum,Class,annotations及这些类型的数组</li>
<li>如果只有一个参数成员,最好将名称设为<strong>value</strong></li>
<li>注解元素必须有确定的值,可以在注解中定义默认值,也可以使用注解时指定,非基本类型的值不可为null,常使用空字符串或0作默认值</li>
<li>在表现一个元素存在或缺失的状态时,定义一下特殊值来表示,如空字符串或负值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(value=RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFieldAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义了一个用在字段上的，运行时有效的名为MyFieldAnnotation的注解，它有两个属性，int类型的id（id后面记得带括号）默认值是0，还有一个String类型的name，默认值是””。</p>
</blockquote>
<h3 id="注解怎么使用？"><a href="#注解怎么使用？" class="headerlink" title="注解怎么使用？"></a>注解怎么使用？</h3><p>在上面我们已经知道了怎么自定义一个注解了，但是光定义没用啊，重要的是我要使用它，使用的方法也很简单，最上面讲反射的时候也提到过几个这样的方法了，比如：<code>class1.isAnnotation()</code>，其实他们统统是java.lang.reflect包下的AnnotatedElement接口里面的方法，这个接口主要有以下几个实现类：</p>
<ul>
<li>Class：类定义</li>
<li>Constructor：构造器定义</li>
<li>Field：累的成员变量定义</li>
<li>Method：类的方法定义</li>
<li>Package：类的包定义 </li>
</ul>
<p><code>java.lang.reflect</code> 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。 AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p>
<ul>
<li>方法1： <code>T getAnnotation(Class annotationClass)</code>: 返回程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li>
<li>方法2：<code>Annotation[] getAnnotations()</code>:返回该程序元素上存在的所有注解。</li>
<li>方法3：<code>boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code>:判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.</li>
<li><p>方法4：<code>Annotation[] getDeclaredAnnotations()</code>：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法<u>将忽略继承的注释</u>。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</p>
<p><strong>总结：定义注解用的是java.lang.annotation.Annotation，操作注解是用java.lang.reflect.AnnotatedElement</strong></p>
</li>
</ul>
<p>测试代码CustomClassAnnotation如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘俊重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 自定义类注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)  <span class="comment">//作用在类，枚举或接口上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">//运行时有效</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">//文档可见</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomClassAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;  <span class="comment">//获取注解名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FruitName类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘俊重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 字段注解（字符串类型的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)  <span class="comment">//用在字段上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FruitColor类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘俊重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 字段注解（枚举类型的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</span><br><span class="line">    <span class="comment">//颜色枚举</span></span><br><span class="line">    <span class="keyword">enum</span> Color&#123;BLUE,RED,GREEN&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//颜色属性</span></span><br><span class="line">    <span class="function">Color <span class="title">color</span><span class="params">()</span> <span class="keyword">default</span> Color.RED</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fruit实体类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘俊重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Fruit实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CustomClassAnnotation</span>(value=<span class="string">"fruit"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitName</span>(name=<span class="string">"apple"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitColor</span>(color= FruitColor.Color.RED)</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类TestAnnotation如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘俊重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Fruit&gt; clazz = Fruit.class; <span class="comment">//反射获取Class对象</span></span><br><span class="line">        CustomClassAnnotation annotation = clazz.getAnnotation(CustomClassAnnotation.class); <span class="comment">//拿到Fruit类的注解</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=annotation &amp;&amp; <span class="string">"fruit"</span>.equals(annotation.value()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Fruit类的注解名是======"</span>+annotation.value());</span><br><span class="line">            <span class="comment">//获取所有的属性遍历，拿到每一个属性的值</span></span><br><span class="line">            Field[] allFields = clazz.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span>(Field field : allFields)&#123;</span><br><span class="line">                <span class="keyword">if</span>(field.isAnnotationPresent(FruitName.class))&#123;</span><br><span class="line">                    <span class="comment">//判断是否存在FruitName注解</span></span><br><span class="line">                    FruitName fruitName = field.getAnnotation(FruitName.class);</span><br><span class="line">                    System.out.println(<span class="string">"水果名称====="</span>+fruitName.name());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(field.isAnnotationPresent(FruitColor.class))&#123;</span><br><span class="line">                    FruitColor fruitColor = field.getAnnotation(FruitColor.class);</span><br><span class="line">                    System.out.println(<span class="string">"水果颜色====="</span>+fruitColor.color());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"注解值不对，请检查"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过注解可以获取到类名，接口名，方法名，属性名，再搭配反射可以动态的生成对象，再搭配动态代理，去动态的去调用某些方法，这基本上也就是spring框架底层实现原理的一部分了。</p>
<p>本文参考：<a href="https://juejin.im/post/5a44c0ad518825455f2f96e5#heading-17。" target="_blank" rel="noopener">https://juejin.im/post/5a44c0ad518825455f2f96e5#heading-17。</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/18/chatbot/" rel="next" title="python项目分层模块导入处理优化">
                <i class="fa fa-chevron-left"></i> python项目分层模块导入处理优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/05/java-8/" rel="prev" title="Java8新特性">
                Java8新特性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Iwhale" />
          <p class="site-author-name" itemprop="name">Iwhale</p>
          <p class="site-description motion-element" itemprop="description">Dream, Such as whales to the sea.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/flyEn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005055406757796/home" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java反射和注解"><span class="nav-number">1.</span> <span class="nav-text">Java反射和注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射机制"><span class="nav-number">1.1.</span> <span class="nav-text">反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用反射机制？"><span class="nav-number">1.1.1.</span> <span class="nav-text">为什么要用反射机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解Class类和类的类型"><span class="nav-number">1.1.2.</span> <span class="nav-text">理解Class类和类的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java反射的主要功能"><span class="nav-number">1.1.3.</span> <span class="nav-text">java反射的主要功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射的相关操作"><span class="nav-number">1.1.4.</span> <span class="nav-text">反射的相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取类的构造函数"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">获取类的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取类的成员变量"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">获取类的成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取类的成员方法"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">获取类的成员方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他方法"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">其他方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过反射了解集合泛型的本质"><span class="nav-number">1.1.5.</span> <span class="nav-text">通过反射了解集合泛型的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理"><span class="nav-number">1.1.6.</span> <span class="nav-text">动态代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注解"><span class="nav-number">1.2.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">1.2.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java注解"><span class="nav-number">1.2.3.</span> <span class="nav-text">java注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java注解类反编译"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">java注解类反编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Target"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">@Target</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Retention"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">@Retention</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Documented"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">@Documented</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inherited"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">@Inherited</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义注解"><span class="nav-number">1.2.4.</span> <span class="nav-text">自定义注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解怎么使用？"><span class="nav-number">1.2.5.</span> <span class="nav-text">注解怎么使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy;  Thu Jan 05 2017 08:00:00 GMT+0800 (中国标准时间) - 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Iwhale</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  




  
  

  

  

  

  


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
<script type="text/javascript" src="//7u2ss1.com1.z0.glb.clouddn.com/love.js"></script>

<a href="https://github.com/flyEn"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/c6625ac1f3ee0a12250227cf83ce904423abf351/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png"></a>
</body>
</html>
