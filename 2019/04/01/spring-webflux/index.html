<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Spring5之使用Spring WebFlux开发响应式应用本文参考：https://blog.51cto.com/liukang/2090163 Spring5之使用Spring WebFlux开发响应式应用。 1.lambda与函数式 2.Reactor 3响应式编程库 3.Spring Webflux和Spring Data Reactive">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring5之使用Spring WebFlux开发响应式应用">
<meta property="og:url" content="http://yoursite.com/2019/04/01/spring-webflux/index.html">
<meta property="og:site_name" content="flyEn&#39;blog">
<meta property="og:description" content="Spring5之使用Spring WebFlux开发响应式应用本文参考：https://blog.51cto.com/liukang/2090163 Spring5之使用Spring WebFlux开发响应式应用。 1.lambda与函数式 2.Reactor 3响应式编程库 3.Spring Webflux和Spring Data Reactive">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155258.png">
<meta property="og:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155259.png">
<meta property="og:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155300.png">
<meta property="og:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155301.png">
<meta property="og:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155302.png">
<meta property="og:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155303.png">
<meta property="og:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155304.png">
<meta property="og:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155308.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/spring-webflux/images/image-20200528164804774.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/spring-webflux/images/image-20200528171159505.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/spring-webflux/images/image-20200528171236497.png">
<meta property="og:image" content="http://yoursite.com/Downloads/typora笔记/images/image-20200528174106393.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/spring-webflux/images/image-20200528174245077.png">
<meta property="og:updated_time" content="2020-11-03T02:58:23.311Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring5之使用Spring WebFlux开发响应式应用">
<meta name="twitter:description" content="Spring5之使用Spring WebFlux开发响应式应用本文参考：https://blog.51cto.com/liukang/2090163 Spring5之使用Spring WebFlux开发响应式应用。 1.lambda与函数式 2.Reactor 3响应式编程库 3.Spring Webflux和Spring Data Reactive">
<meta name="twitter:image" content="http://qaxegk911.bkt.clouddn.com/img/20200528155258.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/01/spring-webflux/"/>





  <title> Spring5之使用Spring WebFlux开发响应式应用 | flyEn'blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">flyEn'blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/spring-webflux/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Iwhale">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="flyEn'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="flyEn'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Spring5之使用Spring WebFlux开发响应式应用
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-01T10:15:42+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Spring5之使用Spring-WebFlux开发响应式应用"><a href="#Spring5之使用Spring-WebFlux开发响应式应用" class="headerlink" title="Spring5之使用Spring WebFlux开发响应式应用"></a>Spring5之使用Spring WebFlux开发响应式应用</h1><p>本文参考：<a href="https://blog.51cto.com/liukang/2090163" target="_blank" rel="noopener">https://blog.51cto.com/liukang/2090163</a></p>
<p>Spring5之使用Spring WebFlux开发响应式应用。</p>
<p><a href="https://blog.51cto.com/liukang/2090187" target="_blank" rel="noopener">1.lambda与函数式</a></p>
<p><a href="https://blog.csdn.net/get_set/article/details/79480172" target="_blank" rel="noopener">2.Reactor 3响应式编程库</a></p>
<p><a href="https://blog.csdn.net/get_set/article/details/79480233" target="_blank" rel="noopener">3.Spring Webflux和Spring Data Reactive</a></p>
<a id="more"></a>
<h2 id="Reactor-3-响应式编程库"><a href="#Reactor-3-响应式编程库" class="headerlink" title="Reactor 3 响应式编程库"></a>Reactor 3 响应式编程库</h2><p>👉<a href="http://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html" target="_blank" rel="noopener">Reactor3参考文档</a></p>
<p>Reactor与Spring是兄弟项目，侧重于Server端的响应式编程，主要 artifact 是 reactor-core，这是一个基于 Java 8 的实现了响应式流规范 （Reactive Streams specification）的响应式库。</p>
<p>我们先把练习用的项目搭起来。先创建一个maven项目，然后添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最新版本可到<a href="http://search.maven.org/" target="_blank" rel="noopener">http://search.maven.org</a>查询，复制过来即可。另外出于测试的需要，添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Flux和Mono"><a href="#Flux和Mono" class="headerlink" title="Flux和Mono"></a>Flux和Mono</h3><p>Reactor中的发布者（Publisher）由Flux和Mono两个类定义，它们都提供了丰富的操作符（operator）。一个Flux对象代表一个包含0..N个元素的响应式序列，而一个Mono对象代表一个包含零/一个（0..1）元素的结果。</p>
<p>既然是“数据流”的发布者，Flux和Mono都可以发出<strong>三种</strong>“数据信号”：<strong>元素值、错误信号、完成信号</strong>，错误信号和完成信号都是终止信号，完成信号用于告知下游订阅者该数据流正常结束，错误信号终止数据流的同时将错误传递给下游订阅者。</p>
<p>下图所示就是一个Flux类型的数据流，黑色箭头是时间轴。它连续发出“1” - “6”共6个元素值，以及一个完成信号（图中⑥后边的加粗竖线来表示），完成信号告知订阅者数据流已经结束。</p>
<p>→<code>Flux.just(1, 2, 3, 4, 5, 6)</code></p>
<p><img src="http://qaxegk911.bkt.clouddn.com/img/20200528155258.png" alt="image-20200528112044589"></p>
<p>下图所示是一个Mono类型的数据流，它发出一个元素值后，又发出一个完成信号。</p>
<p>→<code>Mono.just(1)</code></p>
<p><img src="http://qaxegk911.bkt.clouddn.com/img/20200528155259.png" alt="image-20200528112126526"></p>
<blockquote>
<p>既然Flux具有发布一个数据元素的能力，为什么还要专门定义一个Mono类呢？举个例子，一个HTTP请求产生一个响应，所以对其进行“count”操作是没有多大意义的。表示这样一个结果的话，应该用<code>Mono&lt;HttpResponse&gt;</code>而不是 <code>Flux&lt;HttpResponse&gt;</code>，对应的操作通常只用于处理 0/1 个元素。它们从语义上就原生包含着元素个数的信息，从而避免了对Mono对象进行多元素场景下的处理。</p>
<p>有些操作可以改变基数，从而需要切换类型。比如，count操作用于Flux，但是操作返回的结果是<code>Mono&lt;Long&gt;</code>。</p>
</blockquote>
<p>对于Flux，还可以通过如下方式声明（分别基于数组、集合和Stream生成）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Flux.fromArray(array);</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">Flux.fromIterable(list);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">Flux.fromStream(stream);</span><br></pre></td></tr></table></figure>
<p>三种信号都不是一定要具备的：</p>
<ul>
<li>首先，错误信号和完成信号都是终止信号，<strong>二者不可能同时共存</strong>；</li>
<li>如果没有发出任何一个元素值，而是直接发出完成/错误信号，表示这是一个<strong>空数据流</strong>；</li>
<li><p>如果没有错误信号和完成信号，那么就是一个<strong>无限数据流</strong>。</p>
<p>比如，对于只有完成/错误信号的数据流：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有完成信号的空数据流</span></span><br><span class="line">Flux.just();</span><br><span class="line">Flux.empty();</span><br><span class="line">Mono.empty();</span><br><span class="line">Mono.justOrEmpty(Optional.empty());</span><br><span class="line"><span class="comment">// 只有错误信号的数据流</span></span><br><span class="line">Flux.error(<span class="keyword">new</span> Exception(<span class="string">"some error"</span>));</span><br><span class="line">Mono.error(<span class="keyword">new</span> Exception(<span class="string">"some error"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="订阅前什么都不会发生"><a href="#订阅前什么都不会发生" class="headerlink" title="订阅前什么都不会发生"></a>订阅前什么都不会发生</h3><p>数据流有了，假设我们想把每个数据元素原封不动地打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).subscribe(System.out::print);   <span class="comment">// 输出 123456</span></span><br><span class="line">Mono.just(<span class="number">1</span>).subscribe(System.out::println);  <span class="comment">// 输出  1</span></span><br></pre></td></tr></table></figure>
<p>可见，<code>subscribe</code>方法中的lambda表达式作用在了每一个数据元素上。此外，Flux和Mono还提供了多个<code>subscribe</code>方法的变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅并触发数据流</span></span><br><span class="line">subscribe(); </span><br><span class="line"><span class="comment">// 订阅并指定对正常数据元素如何处理</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer); </span><br><span class="line"><span class="comment">// 订阅并定义对正常数据元素和错误信号的处理</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer); </span><br><span class="line"><span class="comment">// 订阅并定义对正常数据元素、错误信号和完成信号的处理</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,</span><br><span class="line">          Runnable completeConsumer); </span><br><span class="line"><span class="comment">// 订阅并定义对正常数据元素、错误信号和完成信号的处理，以及订阅发生时的处理逻辑</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,</span><br><span class="line">          Runnable completeConsumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Subscription&gt; subscriptionConsumer);</span><br></pre></td></tr></table></figure>
<p>比如订阅上面声明的Flux：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).subscribe(</span><br><span class="line">    System.out::println,</span><br><span class="line">    System.err::println,</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"Completed!"</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">Completed!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举一个有错误信号的例子：</span></span><br><span class="line">Mono.error(<span class="keyword">new</span> Exception(<span class="string">"some error"</span>)).subscribe(</span><br><span class="line">        System.out::println,</span><br><span class="line">        System.err::println,</span><br><span class="line">        () -&gt; System.out.println(<span class="string">"Completed!"</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">java.lang.Exception: some error</span><br></pre></td></tr></table></figure>
<p>这里需要注意的一点是，<code>Flux.just(1, 2, 3, 4, 5, 6)</code>仅仅声明了这个数据流，此时数据元素并未发出，只有<code>subscribe()</code>方法调用的时候才会触发数据流。所以，<strong>订阅前什么都不会发生</strong>。</p>
<h3 id="测试与调试"><a href="#测试与调试" class="headerlink" title="测试与调试"></a>测试与调试</h3><p>从命令式和同步式编程切换到响应式和异步式编程有时候是令人生畏的。学习曲线中最陡峭的地方就是<strong>出错时如何分析和调试</strong>。</p>
<p>在命令式世界，调试通常都是非常直观的：直接看 stack trace 就可以找到问题出现的位置， 以及其他信息：是否问题责任全部出在你自己的代码？问题是不是发生在某些库代码？如果是， 那你的哪部分代码调用了库，是不是传参不合适导致的问题？等等。</p>
<p>当你切换到响应式的异步代码，事情就变得复杂的多了。不过我们先不接触过于复杂的内容，先了解一个基本的单元测试工具——<strong>StepVerifier</strong>。</p>
<p>最常见的测试 Reactor 序列的场景就是定义一个 Flux 或 Mono，然后在订阅它的时候测试它的行为。</p>
<p>当你的测试关注于每一个数据元素的时候，就非常贴近使用 StepVerifier 的测试场景： 下一个期望的数据或信号是什么？你是否期望使用 Flux 来发出某一个特别的值？或者是否接下来 300ms 什么都不做？——所有这些都可以使用 StepVerifier API 来表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Flux&lt;Integer&gt; <span class="title">generateFluxFrom1To6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Mono&lt;Integer&gt; <span class="title">generateMonoWithError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> Exception(<span class="string">"some error"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testViaStepVerifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StepVerifier.create(generateFluxFrom1To6())</span><br><span class="line">            .expectNext(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">            .expectComplete()</span><br><span class="line">            .verify();</span><br><span class="line">    StepVerifier.create(generateMonoWithError())</span><br><span class="line">            .expectErrorMessage(<span class="string">"some error"</span>)</span><br><span class="line">            .verify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>expectNext</code>用于测试下一个期望的数据元素，<code>expectErrorMessage</code>用于校验下一个元素是否为错误信号，<code>expectComplete</code>用于测试下一个元素是否为完成信号。</p>
<h3 id="操作符（Operator）"><a href="#操作符（Operator）" class="headerlink" title="操作符（Operator）"></a>操作符（Operator）</h3><p>通常情况下，我们需要对源发布者发出的原始数据流进行多个阶段的处理，并最终得到我们需要的数据。这种感觉就像是一条流水线，从流水线的源头进入传送带的是原料，经过流水线上各个工位的处理，逐渐由原料变成半成品、零件、组件、成品，最终成为消费者需要的包装品。这其中，流水线源头的下料机就相当于源发布者，消费者就相当于订阅者，流水线上的一道道工序就相当于一个一个的操作符（Operator）。</p>
<h4 id="1）map-元素映射为新元素"><a href="#1）map-元素映射为新元素" class="headerlink" title="1）map-元素映射为新元素"></a>1）map-元素映射为新元素</h4><p><img src="http://qaxegk911.bkt.clouddn.com/img/20200528155300.png" alt="image-20200528114457072"></p>
<p>上图是Flux的map操作示意图，上方的箭头是原始序列的时间轴，下方的箭头是经过map处理后的数据序列时间轴。</p>
<p><code>map</code>接受一个<code>Function</code>的函数式接口为参数，这个函数式的作用是定义转换操作的策略。举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.create(Flux.range(<span class="number">1</span>, <span class="number">6</span>)    <span class="comment">// 1</span></span><br><span class="line">            .map(i -&gt; i * i))   <span class="comment">// 2</span></span><br><span class="line">            .expectNext(<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>)    <span class="comment">//3</span></span><br><span class="line">            .expectComplete();  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>Flux.range(1, 6)</code>用于生成从“1”开始的，自增为1的“6”个整型数据；</li>
<li><code>map</code>接受lambda<code>i -&gt; i * i</code>为参数，表示对每个数据进行平方；</li>
<li>验证新的序列的数据；</li>
<li><code>verifyComplete()</code>相当于<code>expectComplete().verify()</code>。</li>
</ol>
</blockquote>
<h4 id="2）flatMap-元素映射成流"><a href="#2）flatMap-元素映射成流" class="headerlink" title="2）flatMap-元素映射成流"></a>2）flatMap-元素映射成流</h4><p><code>flatMap</code>操作可以将每个数据元素转换/映射为一个流，然后将这些流合并为一个大的数据流。</p>
<p><img src="http://qaxegk911.bkt.clouddn.com/img/20200528155301.png" alt="image-20200528114910438"></p>
<p>注意到，<strong>流的合并是异步的</strong>，先来先到，并非是严格按照原始序列的顺序（如图蓝色和红色方块是交叉的）。</p>
<p><code>flatMap</code>也是接收一个<code>Function</code>的函数式接口为参数，这个函数式的输入为一个T类型数据值，对于Flux来说输出可以是Flux和Mono，对于Mono来说输出只能是Mono。举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.create(</span><br><span class="line">        Flux.just(<span class="string">"flux"</span>, <span class="string">"mono"</span>)</span><br><span class="line">                .flatMap(s -&gt; Flux.fromArray(s.split(<span class="string">"\\s*"</span>))   <span class="comment">// 1</span></span><br><span class="line">                        .delayElements(Duration.ofMillis(<span class="number">100</span>))) <span class="comment">// 2</span></span><br><span class="line">                .doOnNext(System.out::print)) <span class="comment">// 3</span></span><br><span class="line">        .expectNextCount(<span class="number">8</span>) <span class="comment">// 4</span></span><br><span class="line">        .verifyComplete();</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>对于每一个字符串<code>s</code>，将其拆分为包含一个字符的字符串流；</li>
<li>对每个元素延迟100ms；</li>
<li>对每个元素进行打印（注<code>doOnNext</code>方法是“偷窥式”的方法，不会消费数据流）；</li>
<li>验证是否发出了8个元素。</li>
</ol>
</blockquote>
<h4 id="3）filter-过滤"><a href="#3）filter-过滤" class="headerlink" title="3）filter-过滤"></a>3）filter-过滤</h4><p><code>filter</code>操作可以对数据元素进行筛选。</p>
<p><img src="http://qaxegk911.bkt.clouddn.com/img/20200528155302.png" alt="image-20200528115452439"></p>
<p><code>filter</code>接受一个<code>Predicate</code>的函数式接口为参数，这个函数式的作用是进行判断并返回boolean。举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.create(Flux.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">            .filter(i -&gt; i % <span class="number">2</span> == <span class="number">1</span>)    <span class="comment">// 1</span></span><br><span class="line">            .map(i -&gt; i * i))</span><br><span class="line">            .expectNext(<span class="number">1</span>, <span class="number">9</span>, <span class="number">25</span>)   <span class="comment">// 2</span></span><br><span class="line">            .verifyComplete();</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>filter</code>的lambda参数表示过滤操作将保留奇数；</li>
<li>验证仅得到奇数的平方。</li>
</ol>
</blockquote>
<h4 id="4）zip-一对一合并"><a href="#4）zip-一对一合并" class="headerlink" title="4）zip-一对一合并"></a>4）zip-一对一合并</h4><p>看到<code>zip</code>这个词可能会联想到拉链，它能够将多个流一对一的合并起来。zip有多个方法变体，我们介绍一个最常见的二合一的。</p>
<p><img src="http://qaxegk911.bkt.clouddn.com/img/20200528155303.png" alt="image-20200528115732342"></p>
<p>它对两个Flux/Mono流每次各取一个元素，合并为一个二元组（<code>Tuple2</code>）。</p>
<p>举个例子，假设我们有一个关于zip方法的说明：“Zip two sources together, that is to say wait for all the sources to emit one element and combine these elements once into a Tuple2.”，我们希望将这句话拆分为一个一个的单词并以每200ms一个的速度发出，除了前面flatMap的例子中用到的delayElements，可以如下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Flux&lt;String&gt; <span class="title">getZipDescFlux</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String desc = <span class="string">"Zip two sources together, that is to say wait for all the sources to emit one element and combine these elements once into a Tuple2."</span>;</span><br><span class="line">    <span class="keyword">return</span> Flux.fromArray(desc.split(<span class="string">"\\s+"</span>));  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleOperators</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  <span class="comment">// 2</span></span><br><span class="line">    Flux.zip(</span><br><span class="line">            getZipDescFlux(),</span><br><span class="line">            Flux.interval(Duration.ofMillis(<span class="number">200</span>)))  <span class="comment">// 3</span></span><br><span class="line">            .subscribe(t -&gt; System.out.println(t.getT1()), <span class="keyword">null</span>, countDownLatch::countDown);    <span class="comment">// 4</span></span><br><span class="line">    countDownLatch.await(<span class="number">10</span>, TimeUnit.SECONDS);     <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将英文说明用空格拆分为字符串流；<br>定义一个CountDownLatch，初始为1，则会等待执行1次countDown方法后结束，不使用它的话，测试方法所在的线程会直接返回而不会等待数据流发出完毕；<br>使用<strong>Flux.interval</strong>声明一个每200ms发出一个元素的long数据流；因为zip操作是一对一的，故而将其与字符串流zip之后，字符串流也将具有同样的速度；<br>zip之后的流中元素类型为Tuple2，使用getT1方法拿到字符串流的元素；定义完成信号的处理为countDown;<br>countDownLatch.await(10, TimeUnit.SECONDS)会等待countDown倒数至0，最多等待10秒钟。</p>
</blockquote>
<p>除了<code>zip</code>静态方法之外，还有<code>zipWith</code>等非静态方法，效果与之类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getZipDescFlux().zipWith(Flux.interval(Duration.ofMillis(<span class="number">200</span>)))</span><br></pre></td></tr></table></figure>
<p>在异步条件下，数据流的流速不同，使用zip能够一对一地将两个或多个数据流的元素对齐发出。</p>
<h4 id="5）更多"><a href="#5）更多" class="headerlink" title="5）更多"></a>5）更多</h4><p>Reactor中提供了非常丰富的操作符，除了以上几个常见的，还有：</p>
<ul>
<li>用于编程方式自定义生成数据流的<code>create</code>和<code>generate</code>等及其变体方法；</li>
<li>用于“无副作用的peek”场景的<code>doOnNext</code>、<code>doOnError</code>、<code>doOncomplete</code>、<code>doOnSubscribe</code>、<code>doOnCancel</code>等及其变体方法；</li>
<li>用于数据流转换的<code>when</code>、<code>and/or</code>、<code>merge</code>、<code>concat</code>、<code>collect</code>、<code>count</code>、<code>repeat</code>等及其变体方法；</li>
<li>用于过滤/拣选的<code>take</code>、<code>first</code>、<code>last</code>、<code>sample</code>、<code>skip</code>、<code>limitRequest</code>等及其变体方法；</li>
<li>用于错误处理的<code>timeout</code>、<code>onErrorReturn</code>、<code>onErrorResume</code>、<code>doFinally</code>、<code>retryWhen</code>等及其变体方法；</li>
<li>用于分批的<code>window</code>、<code>buffer</code>、<code>group</code>等及其变体方法；</li>
<li>用于线程调度的<code>publishOn</code>和<code>subscribeOn</code>方法。</li>
</ul>
<p>使用这些操作符，你几乎可以搭建出能够进行任何业务需求的数据处理管道/流水线。</p>
<p>详细可阅读<a href="http://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html" target="_blank" rel="noopener">Reactor3参考文档</a>。</p>
<h3 id="调度器与线程模型"><a href="#调度器与线程模型" class="headerlink" title="调度器与线程模型"></a>调度器与线程模型</h3><p>在Reactor中，对于多线程并发调度的处理变得异常简单。</p>
<p>在以往的多线程开发场景中，我们通常使用<code>Executors</code>工具类来创建线程池，通常有如下四种类型：</p>
<ul>
<li><code>newCachedThreadPool</code>创建一个弹性大小缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程；</li>
<li><code>newFixedThreadPool</code>创建一个大小固定的线程池，可控制线程最大并发数，超出的线程会在队列中等待；</li>
<li><code>newScheduledThreadPool</code>创建一个大小固定的线程池，支持定时及周期性的任务执行；</li>
<li><code>newSingleThreadExecutor</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>
<p>此外，<code>newWorkStealingPool</code>还可以创建支持work-stealing的线程池。</p>
<p>说良心话，Java提供的<code>Executors</code>工具类使得我们对<code>ExecutorService</code>使用已经非常得心应手了。BUT~ Reactor让线程管理和任务调度更加“傻瓜”——调度器（Scheduler）帮助我们搞定这件事。<code>Scheduler</code>是一个拥有多个实现类的抽象接口。Schedulers类提供的静态方法可搭建以下几种线程执行环境：</p>
<ul>
<li>当前线程（<code>Schedulers.immediate()</code>）;</li>
<li>可重用的单线程（<code>Schedulers.single()</code>）。注意，这个方法对所有调用者都提供同一个线程来使用， 直到该调度器被废弃。如果你想使用独占的线程，请使用<code>Schedulers.newSingle()</code>；</li>
<li>弹性线程池（<code>Schedulers.elastic()</code>）。它根据需要创建一个线程池，重用空闲线程。线程池如果空闲时间过长 （默认为 60s）就会被废弃。对于 I/O 阻塞的场景比较适用。<code>Schedulers.elastic()</code>能够方便地给一个阻塞 的任务分配它自己的线程，从而不会妨碍其他任务和资源；</li>
<li>固定大小线程池（<code>Schedulers.parallel()</code>），所创建线程池的大小与CPU个数等同；</li>
<li>自定义线程池（<code>Schedulers.fromExecutorService(ExecutorService)</code>）基于自定义的ExecutorService创建 Scheduler（虽然不太建议，不过你也可以使用Executor来创建）。</li>
</ul>
<p><code>Schedulers</code>类已经预先创建了几种常用的线程池：使用<code>single()</code>、<code>elastic()</code>和<code>parallel()</code>方法可以分别使用内置的单线程、弹性线程池和固定大小线程池。如果想创建新的线程池，可以使用<code>newSingle()</code>、<code>newElastic()</code>和<code>newParallel()</code>方法。</p>
<p><code>Executors</code>提供的几种线程池在Reactor中都支持：</p>
<ul>
<li><code>Schedulers.single()</code>和<code>Schedulers.newSingle()</code>对应<code>Executors.newSingleThreadExecutor()</code>；</li>
<li><code>Schedulers.elastic()</code>和<code>Schedulers.newElastic()</code>对应<code>Executors.newCachedThreadPool()</code>；</li>
<li><code>Schedulers.parallel()</code>和<code>Schedulers.newParallel()</code>对应<code>Executors.newFixedThreadPool()</code>；</li>
</ul>
<p><strong>举例：将同步的阻塞调用变为异步的</strong></p>
<p>前面介绍到<code>Schedulers.elastic()</code>能够方便地给一个阻塞的任务分配专门的线程，从而不会妨碍其他任务和资源。我们就可以利用这一点将一个同步阻塞的调用调度到一个自己的线程中，并利用订阅机制，待调用结束后异步返回。</p>
<p>假设我们有一个同步阻塞的调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getStringSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, Reactor!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下，调用这个方法会被阻塞2秒钟，然后同步地返回结果。我们借助elastic调度器将其变为异步，由于是异步的，为了保证测试方法所在的线程能够等待结果的返回，我们使用<code>CountDownLatch</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSyncToAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    Mono.fromCallable(() -&gt; getStringSync())    <span class="comment">// 1</span></span><br><span class="line">            .subscribeOn(Schedulers.elastic())  <span class="comment">// 2</span></span><br><span class="line">            .subscribe(System.out::println, <span class="keyword">null</span>, countDownLatch::countDown);</span><br><span class="line">    countDownLatch.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>使用<code>fromCallable</code>声明一个基于Callable的Mono；</li>
<li>使用<code>subscribeOn</code>将任务调度到<code>Schedulers</code>内置的弹性线程池执行，弹性线程池会为Callable的执行任务分配一个单独的线程。</li>
</ol>
</blockquote>
<p><strong>切换调度器的操作符</strong></p>
<p>Reactor 提供了两种在响应式链中调整调度器 Scheduler的方法：<code>publishOn</code>和<code>subscribeOn</code>。它们都接受一个 <code>Scheduler</code>作为参数，从而可以改变调度器。但是<code>publishOn</code>在链中出现的位置是有讲究的，而<code>subscribeOn</code> 则无所谓。</p>
<p><img src="http://qaxegk911.bkt.clouddn.com/img/20200528155304.png" alt="image-20200528141933004"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设与上图对应的代码是：</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">.map(…)</span><br><span class="line">.publishOn(Schedulers.elastic()).filter(…)</span><br><span class="line">.publishOn(Schedulers.parallel()).flatMap(…)</span><br><span class="line">.subscribeOn(Schedulers.single())</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如图所示，<code>publishOn</code>会影响链中其后的操作符，比如第一个publishOn调整调度器为elastic，则<code>filter</code>的处理操作是在弹性线程池中执行的；同理，<code>flatMap</code>是执行在固定大小的parallel线程池中的;</li>
<li><code>subscribeOn</code>无论出现在什么位置，都只影响源头的执行环境，也就是<code>range</code>方法是执行在单线程中的，直至被第一个<code>publishOn</code>切换调度器之前，所以<code>range</code>后的<code>map</code>也在单线程中执行。</li>
</ul>
</blockquote>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在响应式流中，错误（error）是终止信号。当有错误发生时，它会导致流序列停止，并且错误信号会沿着操作链条向下传递，直至遇到subscribe中的错误处理方法。这样的错误还是应该在应用层面解决的。否则，你可能会将错误信息显示在用户界面，或者通过某个REST endpoint发出。所以还是建议在subscribe时通过错误处理方法妥善解决错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testErrorHandling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Flux.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">            .map(i -&gt; <span class="number">10</span>/(i-<span class="number">3</span>)) <span class="comment">// 1</span></span><br><span class="line">            .map(i -&gt; i*i)</span><br><span class="line">            .subscribe(System.out::println, System.err::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当i为3时会导致异常。</p>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">java.lang.ArithmeticException: / by zero    <span class="comment">//注：这一行是红色，表示标准错误输出</span></span><br></pre></td></tr></table></figure>
<p><code>subscribe</code>方法的第二个参数定义了对错误信号的处理，从而测试方法exit为0（即正常退出），可见错误没有蔓延出去。不过这还不够~</p>
<p>此外，Reactor还提供了其他的用于在链中处理错误的操作符（error-handling operators），使得对于错误信号的处理更加及时，处理方式更加多样化。</p>
<p>在讨论错误处理操作符的时候，我们借助命令式编程风格的 try 代码块来作比较。我们都很熟悉在 try-catch 代码块中处理异常的几种方法。常见的包括如下几种：</p>
<ol>
<li>捕获并返回一个静态的缺省值。</li>
<li>捕获并执行一个异常处理方法或动态计算一个候补值来顶替。</li>
<li>捕获，并再包装为某一个 业务相关的异常，然后再抛出业务异常。</li>
<li>捕获，记录错误日志，然后继续抛出。</li>
<li>使用 finally 来清理资源，或使用 Java 7 引入的 “try-with-resource”。</li>
</ol>
<p>以上所有这些在 Reactor 都有相应的基于 error-handling 操作符处理方式。</p>
<h4 id="1-捕获并返回一个静态的缺省值。"><a href="#1-捕获并返回一个静态的缺省值。" class="headerlink" title="1. 捕获并返回一个静态的缺省值。"></a>1. 捕获并返回一个静态的缺省值。</h4><p><code>onErrorReturn</code>方法能够在收到错误信号的时候提供一个缺省值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    .map(i -&gt; <span class="number">10</span>/(i-<span class="number">3</span>))</span><br><span class="line">    .onErrorReturn(<span class="number">0</span>)   <span class="comment">// 1</span></span><br><span class="line">    .map(i -&gt; i*i)</span><br><span class="line">    .subscribe(System.out::println, System.err::println);</span><br><span class="line"><span class="comment">// 当发生异常时提供一个缺省值0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-捕获并执行一个异常处理方法或计算一个候补值来顶替"><a href="#2-捕获并执行一个异常处理方法或计算一个候补值来顶替" class="headerlink" title="2. 捕获并执行一个异常处理方法或计算一个候补值来顶替"></a>2. 捕获并执行一个异常处理方法或计算一个候补值来顶替</h4><p><code>onErrorResume</code>方法能够在收到错误信号的时候提供一个新的数据流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    .map(i -&gt; <span class="number">10</span>/(i-<span class="number">3</span>))</span><br><span class="line">    .onErrorResume(e -&gt; Mono.just(<span class="keyword">new</span> Random().nextInt(<span class="number">6</span>))) <span class="comment">// 提供新的数据流</span></span><br><span class="line">    .map(i -&gt; i*i)</span><br><span class="line">    .subscribe(System.out::println, System.err::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举一个更有业务含义的例子：</span></span><br><span class="line"><span class="comment">// 1. 调用外部服务。</span></span><br><span class="line"><span class="comment">// 2. 如果外部服务异常，则从缓存中取值代替。</span></span><br><span class="line">Flux.just(endpoint1, endpoint2)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k))   <span class="comment">// 1</span></span><br><span class="line">    .onErrorResume(e -&gt; getFromCache(k));   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-捕获，并再包装为某一个业务相关的异常，然后再抛出业务异常"><a href="#3-捕获，并再包装为某一个业务相关的异常，然后再抛出业务异常" class="headerlink" title="3. 捕获，并再包装为某一个业务相关的异常，然后再抛出业务异常"></a>3. 捕获，并再包装为某一个业务相关的异常，然后再抛出业务异常</h4><p>有时候，我们收到异常后并不想立即处理，而是会包装成一个业务相关的异常交给后续的逻辑处理，可以使用<code>onErrorMap</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"timeout1"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k))   <span class="comment">// 1</span></span><br><span class="line">    .onErrorMap(original -&gt; <span class="keyword">new</span> BusinessException(<span class="string">"SLA exceeded"</span>, original)); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1. 调用外部服务</span></span><br><span class="line"><span class="comment">// 2. 如果外部服务异常，将其包装为业务相关的异常后再次抛出</span></span><br><span class="line"><span class="comment">// 相当于onErrorResume如下实现：</span></span><br><span class="line">Flux.just(<span class="string">"timeout1"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k))</span><br><span class="line">    .onErrorResume(original -&gt; Flux.error(</span><br><span class="line">        <span class="keyword">new</span> BusinessException(<span class="string">"SLA exceeded"</span>, original));</span><br></pre></td></tr></table></figure>
<h4 id="4-捕获，记录错误日志，然后继续抛出"><a href="#4-捕获，记录错误日志，然后继续抛出" class="headerlink" title="4. 捕获，记录错误日志，然后继续抛出"></a>4. 捕获，记录错误日志，然后继续抛出</h4><p>如果对于错误你只是想在不改变它的情况下做出响应（如记录日志），并让错误继续传递下去， 那么可以用<code>doOnError</code> 方法。前面提到，形如<code>doOnXxx</code>是只读的，对数据流不会造成影响：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(endpoint1, endpoint2)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k)) </span><br><span class="line">    .doOnError(e -&gt; &#123;   <span class="comment">// 1</span></span><br><span class="line">        log(<span class="string">"uh oh, falling back, service failed for key "</span> + k);    <span class="comment">// 2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .onErrorResume(e -&gt; getFromCache(k));</span><br></pre></td></tr></table></figure>
<h4 id="5-使用-finally-来清理资源，或使用-Java-7-引入的-“try-with-resource”"><a href="#5-使用-finally-来清理资源，或使用-Java-7-引入的-“try-with-resource”" class="headerlink" title="5. 使用 finally 来清理资源，或使用 Java 7 引入的 “try-with-resource”"></a>5. 使用 finally 来清理资源，或使用 Java 7 引入的 “try-with-resource”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.using(</span><br><span class="line">        () -&gt; getResource(),    <span class="comment">// 1</span></span><br><span class="line">        resource -&gt; Flux.just(resource.getAll()),   <span class="comment">// 2</span></span><br><span class="line">        MyResource::clean   <span class="comment">// 3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>第一个参数获取资源；</li>
<li>第二个参数利用资源生成数据流；</li>
<li>第三个参数最终清理资源。</li>
</ol>
</blockquote>
<p>另一方面， <code>doFinally</code>在序列终止（无论是 onComplete、<code>onError</code>还是取消）的时候被执行， 并且能够判断是什么类型的终止事件（完成、错误还是取消），以便进行针对性的清理。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LongAdder statsCancel = <span class="keyword">new</span> LongAdder();    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.just(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</span><br><span class="line">    .doFinally(type -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == SignalType.CANCEL)  <span class="comment">// 2</span></span><br><span class="line">          statsCancel.increment();  <span class="comment">// 3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .take(<span class="number">1</span>);   <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>用<code>LongAdder</code>进行统计；</li>
<li><code>doFinally</code>用<code>SignalType</code>检查了终止信号的类型；</li>
<li>如果是取消，那么统计数据自增；</li>
<li><code>take(1)</code>能够在发出1个元素后取消流。</li>
</ol>
</blockquote>
<h4 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h4><p>还有一个用于错误处理的操作符你可能会用到，就是<code>retry</code>，见文知意，用它可以对出现错误的序列进行重试。</p>
<p>请注意：<strong>retry</strong>对于上游Flux是采取的重订阅（re-subscribing）的方式，因此重试之后实际上已经一个不同的序列了， 发出错误信号的序列仍然是终止了的。举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    .map(i -&gt; <span class="number">10</span> / (<span class="number">3</span> - i))</span><br><span class="line">    .retry(<span class="number">1</span>)</span><br><span class="line">    .subscribe(System.out::println, System.err::println);</span><br><span class="line">Thread.sleep(<span class="number">100</span>);  <span class="comment">// 确保序列执行完</span></span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure>
<p>可见，<code>retry</code>不过是再一次从新订阅了原始的数据流，从1开始。第二次，由于异常再次出现，便将异常传递到下游了。</p>
<h3 id="回压"><a href="#回压" class="headerlink" title="回压"></a>回压</h3><p>前边的例子并没有进行流量控制，也就是，当执行<code>.subscribe(System.out::println)</code>这样的订阅的时候，直接发起了一个无限的请求（unbounded request），就是对于数据流中的元素无论快慢都“照单全收”。</p>
<p><code>subscribe</code>方法还有一个变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收一个Subscriber为参数，该Subscriber可以进行更加灵活的定义</span></span><br><span class="line">subscribe(Subscriber subscriber)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：其实这才是<code>subscribe</code>方法本尊，前边介绍到的可以接收0~4个函数式接口为参数的<code>subscribe</code>最终都是拼装为这个方法，所以按理说前边的<code>subscribe</code>方法才是“变体”。</p>
</blockquote>
<p>我们可以通过自定义具有流量控制能力的Subscriber进行订阅。Reactor提供了一个<code>BaseSubscriber</code>，我们可以通过扩展它来定义自己的Subscriber。</p>
<p>假设，我们现在有一个非常快的Publisher——<code>Flux.range(1, 6)</code>，然后自定义一个每秒处理一个数据元素的慢的Subscriber，Subscriber就需要通过<code>request(n)</code>的方法来告知上游它的需求速度。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBackpressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Flux.range(<span class="number">1</span>, <span class="number">6</span>)    <span class="comment">// 1</span></span><br><span class="line">            .doOnRequest(n -&gt; System.out.println(<span class="string">"Request "</span> + n + <span class="string">" values..."</span>))    <span class="comment">// 2</span></span><br><span class="line">            .subscribe(<span class="keyword">new</span> BaseSubscriber&lt;Integer&gt;() &#123;  <span class="comment">// 3</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123; <span class="comment">// 4</span></span><br><span class="line">                    System.out.println(<span class="string">"Subscribed and make a request..."</span>);</span><br><span class="line">                    request(<span class="number">1</span>); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Integer value)</span> </span>&#123;  <span class="comment">// 6</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);  <span class="comment">// 7</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"Get value ["</span> + value + <span class="string">"]"</span>);    <span class="comment">// 8</span></span><br><span class="line">                    request(<span class="number">1</span>); <span class="comment">// 9</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>Flux.range</code>是一个快的Publisher；</li>
<li>在每次<code>request</code>的时候打印request个数；</li>
<li>通过重写<code>BaseSubscriber</code>的方法来自定义Subscriber；</li>
<li><code>hookOnSubscribe</code>定义在订阅的时候执行的操作；</li>
<li>订阅时首先向上游请求1个元素；</li>
<li><code>hookOnNext</code>定义每次在收到一个元素的时候的操作；</li>
<li>sleep 1秒钟来模拟慢的Subscriber；</li>
<li>打印收到的元素；</li>
<li>每次处理完1个元素后再请求1个。</li>
</ol>
<p>输出如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Subscribed and make a request...</span><br><span class="line">Request <span class="number">1</span> values...</span><br><span class="line">Get value [<span class="number">1</span>]</span><br><span class="line">Request <span class="number">1</span> values...</span><br><span class="line">Get value [<span class="number">2</span>]</span><br><span class="line">Request <span class="number">1</span> values...</span><br><span class="line">Get value [<span class="number">3</span>]</span><br><span class="line">Request <span class="number">1</span> values...</span><br><span class="line">Get value [<span class="number">4</span>]</span><br><span class="line">Request <span class="number">1</span> values...</span><br><span class="line">Get value [<span class="number">5</span>]</span><br><span class="line">Request <span class="number">1</span> values...</span><br><span class="line">Get value [<span class="number">6</span>]</span><br><span class="line">Request <span class="number">1</span> values...</span><br></pre></td></tr></table></figure>
<p>这6个元素是以每秒1个的速度被处理的。由此可见<code>range</code>方法生成的Flux采用的是缓存的回压策略，能够缓存下游暂时来不及处理的元素。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上关于Reactor的介绍主要是概念层面和使用层面的介绍，不过应该也足以应对常见的业务环境了。</p>
<p>从命令式编程到响应式编程的切换并不是一件容易的事，需要一个适应的过程。不过相信你通过本节的了解和实操，已经可以体会到使用Reactor编程的一些<strong>特点</strong>：</p>
<ul>
<li>相对于传统的基于回调和Future的异步开发方式，<strong>响应式编程更加具有可编排性和可读性</strong>，配合lambda表达式，代码更加<strong>简洁</strong>，处理逻辑的表达就像装配“流水线”，适用于对数据流的处理；</li>
<li>在订阅（subscribe）时才触发数据流，这种数据流叫做<strong>“冷”数据流</strong>，就像插座插上电器才会有电流一样，还有一种数据流不管是否有订阅者订阅它都会一直发出数据，称之为<strong>“热”数据流</strong>，Reactor中几乎都是“冷”数据流；</li>
<li><strong>调度器对线程管理进行更高层次的抽象</strong>，使得我们可以非常容易地切换线程执行环境；</li>
<li><strong>灵活的错误处理机制</strong>有利于编写健壮的程序；</li>
<li><strong>“回压”机制</strong>使得订阅者可以无限接受数据并让它的源头“满负荷”推送所有的数据，也可以通过使用request方法来告知源头它一次最多能够处理 n 个元素，从而将“推送”模式转换为<strong>“推送+拉取”</strong>混合的模式。<br>后续随着对Reactor的了解我们还会逐渐了解它更多的好玩又好用的特性。</li>
</ul>
<p>Reactor的开发者中也有来自RxJava的大牛，因此Reactor中甚至许多方法名都是来自RxJava的API的，学习了Reactor之后，很轻松就可以上手Rx家族的库了。</p>
<h2 id="Spring-WebFlux"><a href="#Spring-WebFlux" class="headerlink" title="Spring WebFlux"></a>Spring WebFlux</h2><p>Spring WebFlux是随Spring 5推出的响应式Web框架。</p>
<p><strong>1）服务端技术栈</strong></p>
<p>Spring提供了完整的支持响应式的服务端技术栈。</p>
<p>如上图所示，左侧为基于spring-webmvc的技术栈，右侧为基于spring-webflux的技术栈，</p>
<ul>
<li><p>Spring WebFlux是基于响应式流的，因此可以用来建立异步的、非阻塞的、事件驱动的服务。它采用<strong>Reactor</strong>作为首选的响应式流的实现库，不过也提供了对RxJava的支持。</p>
</li>
<li><p>由于响应式编程的特性，Spring WebFlux和Reactor底层需要支持异步的运行环境，比如Netty和Undertow；也可以运行在支持异步I/O的Servlet 3.1的容器之上，比如Tomcat（8.0.23及以上）和Jetty（9.0.4及以上）。</p>
</li>
<li><p>从图的纵向上看，spring-webflux上层支持两种开发模式：</p>
<ul>
<li><p>类似于Spring WebMVC的基于注解（<code>@Controller</code>、<code>@RequestMapping</code>）的开发模式；</p>
</li>
<li><p>Java 8 lambda 风格的函数式开发模式。</p>
</li>
</ul>
</li>
<li><p>Spring WebFlux也支持响应式的Websocket服务端开发。</p>
</li>
</ul>
<blockquote>
<p>由此看来，Spring WebFlux与Vert.x有一些相通之处，都是建立在非阻塞的异步I/O和事件驱动的基础之上的。</p>
</blockquote>
<p><strong>2）响应式http客户端</strong></p>
<p>此外，Spring WebFlux也提供了一个响应式的Http客户端API <code>WebClient</code>。它可以用函数式的方式异步非阻塞地发起Http请求并处理响应。其底层也是由Netty提供的异步支持。</p>
<p>我们可以把<code>WebClient</code>看做是响应式的<code>RestTemplate</code>，与后者相比，前者：</p>
<ul>
<li>是非阻塞的，可以基于少量的线程处理更高的并发；</li>
<li>可以使用Java 8 lambda表达式；</li>
<li>支持异步的同时也可以支持同步的使用方式；</li>
<li>可以通过数据流的方式与服务端进行双向通信。</li>
</ul>
<p>当然，与服务端对应的，Spring WebFlux也提供了响应式的Websocket客户端API。</p>
<p>本节，我们仍然是本着“Hello，world！”的精神来上手熟悉WebFlux，因此暂时不会像手册一样面面俱到地谈到WebFlux的各个细节，我们通过以下几个例子来了解它：</p>
<ol>
<li>先介绍一下使用Spring WebMVC风格的基于注解的方式如何编写响应式的Web服务，这几乎没有学习成本，非常赞。虽然这种方式在开发上与Spring WebMVC变化不大，但是框架底层已经是完全的响应式技术栈了；</li>
<li>再进一步介绍函数式的开发模式；</li>
<li>简单几行代码实现服务端推送（Server Send Event，SSE）；</li>
<li>然后我们再加入响应式数据库的支持（使用Reactive Spring Data for MongoDB）；</li>
<li>使用<strong>WebClient</strong>与前几步做好的服务端进行通信；</li>
<li>最后我们看一下如何通过“流”的方式在Http上进行通信。</li>
</ol>
<p>Spring Boot 2是基于Spring 5的，其中一个比较大的更新就在于支持包括spring-webflux和响应式的spring-data在内的响应式模块。Spring Boot 2即将发布正式版，不过目前的版本从功能上已经完备，下边的例子我们就用Spring Boot 2在进行搭建。</p>
<h3 id="基于WebMVC注解的方式"><a href="#基于WebMVC注解的方式" class="headerlink" title="基于WebMVC注解的方式"></a>基于WebMVC注解的方式</h3><p>我们首先用Spring WebMVC开发一个只有Controller层的简单的Web服务，然后仅仅做一点点调整就可切换为基于Spring WebFlux的具有同样功能的Web服务。</p>
<p>我们使用Spring Boot 2搭建项目框架。</p>
<p><strong>1）基于Spring Initializr创建项目</strong></p>
<p>本节的例子很简单，不涉及Service层和Dao层，因此只选择spring-webmvc即可，也就是“Web”的starter。</p>
<p>也可以使用网页版的<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io</a>来创建项目：</p>
<p>创建后的项目POM中，包含下边的依赖，即表示基于Spring WebMVC：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2）创建Controller和Endpoint</strong></p>
<p>创建Controller类<code>HelloController</code>，仅提供一个Endpoint：<code>/hello</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to reactive world ~"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3）启动应用</strong></p>
<p>OK了，一个简单的基于Spring WebMVC的Web服务。我们新增了<code>HelloController.java</code>，修改了<code>application.properties</code>。</p>
<p><img src="http://qaxegk911.bkt.clouddn.com/img/20200528155308.png" alt="image-20200528154935726"></p>
<p>使用IDE启动应用，或使用maven命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure>
<p>测试Endpoint。在浏览器中访问<code>http://localhost:8080/hello</code>，或运行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/hello</span><br></pre></td></tr></table></figure>
<p>返回<code>Welcome to reactive world ~</code>。</p>
<p>基于Spring WebFlux的项目与上边的步骤一致，仅有两点不同。我们这次偷个懒，就不从新建项目了，修改一下上边的项目：</p>
<p><strong>4）依赖“Reactive Web”的starter是webflux而不是“Web”</strong></p>
<p>修改项目POM，调整依赖使其基于Spring WebFlux：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="comment">&lt;!--【改】增加“flux”四个字符--&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>5）Controller中处理请求的返回类型采用响应式类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">hello</span><span class="params">()</span> </span>&#123;   <span class="comment">// 【改】返回类型为Mono&lt;String&gt;</span></span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="string">"Welcome to reactive world ~"</span>);     <span class="comment">// 【改】使用Mono.just生成响应式数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6）启动应用</strong></p>
<p>仅需要上边两步就改完了，是不是很简单，同样的方法启动应用。启动后发现应用运行于Netty上：</p>
<p>访问<code>http://localhost:8080/hello</code>，结果与Spring WebMVC的相同。</p>
<p><strong>7）总结</strong></p>
<p>从上边这个非常非常简单的例子中可以看出，Spring真是用心良苦，WebFlux提供了与之前WebMVC相同的一套注解来定义请求的处理，使得Spring使用者迁移到响应式开发方式的过程变得异常轻松。</p>
<p>虽然我们只修改了少量的代码，但是其实这个简单的项目已经脱胎换骨了。整个技术栈从命令式的、同步阻塞的【spring-webmvc + servlet + Tomcat】变成了响应式的、异步非阻塞的【spring-webflux + Reactor + Netty】。</p>
<p><strong>Netty</strong>是一套异步的、事件驱动的<strong>网络应用程序框架</strong>和工具，能够开发高性能、高可靠性的网络服务器和客户端程序，因此与同样是异步的、事件驱动的响应式编程范式一拍即合。</p>
<blockquote>
<p>下边的内容了解即可，就不实战了。<br>在Java 7推出异步I/O库，以及Servlet3.1增加了对异步I/O的支持之后，Tomcat等Servlet容器也随后开始支持异步I/O，然后Spring WebMVC也增加了对Reactor库的支持，所以上边第4）步如果不是将spring-boot-starter-web替换为spring-boot-starter-WebFlux，而是增加reactor-core的依赖的话，仍然可以用注解的方式开发基于Tomcat的响应式应用。</p>
</blockquote>
<h3 id="WebFlux的函数式开发模式"><a href="#WebFlux的函数式开发模式" class="headerlink" title="WebFlux的函数式开发模式"></a>WebFlux的函数式开发模式</h3><p>既然是响应式编程了，有些朋友可能会想统一用函数式的编程风格，WebFlux满足你。WebFlux提供了一套函数式接口，可以用来实现类似MVC的效果。我们先接触两个常用的。</p>
<p>再回头瞧一眼上边例子中我们用<code>Controller</code>定义定义对Request的处理逻辑的方式，主要有两个点：</p>
<ol>
<li>方法定义处理逻辑；</li>
<li>然后用<code>@RequestMapping</code>注解定义好这个方法对什么样url进行响应。</li>
</ol>
<p>在WebFlux的函数式开发模式中，我们用<code>HandlerFunction</code>和<code>RouterFunction</code>来实现上边这两点。</p>
<ul>
<li><p><code>HandlerFunction</code>相当于<code>Controller</code>中的具体处理方法，输入为请求，输出为装在<code>Mono</code>中的响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;T extends ServerResponse&gt; handle(ServerRequest request);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RouterFunction</code>，顾名思义，路由，相当于<code>@RequestMapping</code>，用来判断什么样的url映射到那个具体的<code>HandlerFunction</code>，输入为请求，输出为装在Mono里边的<code>Handlerfunction</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;HandlerFunction&lt;T&gt;&gt; route(ServerRequest request);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们看到，在WebFlux中，请求和响应不再是WebMVC中的<code>ServletRequest</code>和<code>ServletResponse</code>，而是<code>ServerRequest</code>和<code>ServerResponse</code>。后者是在响应式编程中使用的接口，它们提供<strong>了对非阻塞和回压特性的支持</strong>，以及Http消息体与响应式类型Mono和Flux的转换方法。</p>
<p>下面我们用函数式的方式开发两个Endpoint：</p>
<ol>
<li><code>time</code>返回当前的时间；</li>
<li><code>/date</code>返回当前的日期。</li>
</ol>
<p>对于这两个需求，HandlerFunction很容易写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回包含时间字符串的ServerResponse</span></span><br><span class="line">HandlerFunction&lt;ServerResponse&gt; timeFunction = </span><br><span class="line">    request -&gt; ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(</span><br><span class="line">        Mono.just(<span class="string">"Now is "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date())), String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回包含日期字符串的ServerResponse</span></span><br><span class="line">HandlerFunction&lt;ServerResponse&gt; dateFunction = </span><br><span class="line">    request -&gt; ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(</span><br><span class="line">        Mono.just(<span class="string">"Today is "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(<span class="keyword">new</span> Date())), String.class);</span><br></pre></td></tr></table></figure>
<p>那么RouterFunction为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; router = </span><br><span class="line">    RouterFunctions.route(GET(<span class="string">"/time"</span>), timeFunction)</span><br><span class="line">        .andRoute(GET(<span class="string">"/date"</span>), dateFunction);</span><br></pre></td></tr></table></figure>
<p>不过这么写在业务逻辑复杂的时候不太好组织，我们通常采用跟MVC类似的代码组织方式，将同类业务的HandlerFunction放在一个类中，然后在Java Config中将RouterFunction配置为Spring容器的Bean。我们继续在第一个例子的代码上开发：</p>
<p><strong>1）创建统一存放处理时间的Handler类</strong></p>
<p>创建<code>TimeHandler.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.ok;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getTime</span><span class="params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ok().contentType(MediaType.TEXT_PLAIN).body(Mono.just(<span class="string">"Now is "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date())), String.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getDate</span><span class="params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ok().contentType(MediaType.TEXT_PLAIN).body(Mono.just(<span class="string">"Today is "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(<span class="keyword">new</span> Date())), String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于出现次数通常比较多，这里静态引入<code>ServerResponse.ok()</code>方法。</p>
</blockquote>
<p><strong>2）在Spring容器配置RouterFunction</strong></p>
<p>我们采用Spring现在比较推荐的Java Config的配置Bean的方式，创建用于存放Router的配置类<code>RouterConfig.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.GET;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TimeHandler timeHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">timerRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">"/time"</span>), req -&gt; timeHandler.getTime(req))</span><br><span class="line">                .andRoute(GET(<span class="string">"/date"</span>), timeHandler::getDate);  <span class="comment">// 这种方式相对于上一行更加简洁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3）重启服务试一试</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl http://localhost:8080/date</span><br><span class="line">Today is 2018-02-26</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> curl http://localhost:8080/time</span><br><span class="line">Now is 21:12:53</span><br></pre></td></tr></table></figure>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>我们可能会遇到一些需要<em>网页与服务器端保持连接</em>（起码看上去是保持连接）的需求，比如类似微信网页版的聊天类应用，比如需要频繁更新页面数据的监控系统页面或股票看盘页面。我们通常采用如下几种技术：</p>
<ul>
<li>短轮询：利用<code>ajax</code>定期向服务器请求，无论数据是否更新立马返回数据，高并发情况下可能会对服务器和带宽造成压力；</li>
<li>长轮询：利用<code>comet</code>不断向服务器发起请求，服务器将请求暂时挂起，直到有新的数据的时候才返回，相对短轮询减少了请求次数；</li>
<li>SSE：服务端推送（<strong>Server Send Event</strong>），在客户端发起一次请求后会保持该连接，服务器端基于该连接持续向客户端发送数据，从HTML5开始加入。</li>
<li>Websocket：这是也是一种保持连接的技术，并且是双向的，从HTML5开始加入，并非完全基于HTTP，适合于频繁和较大流量的双向通讯场景。</li>
</ul>
<p>既然响应式编程是一种基于数据流的编程范式，自然在服务器推送方面得心应手，我们基于函数式方式再增加一个Endpoint <code>/times</code>，可以每秒推送一次时间。</p>
<p><strong>1）增加Handler方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">sendTimePerSec</span><span class="params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ok().contentType(MediaType.TEXT_EVENT_STREAM).body(  <span class="comment">// 1</span></span><br><span class="line">            Flux.interval(Duration.ofSeconds(<span class="number">1</span>)).   <span class="comment">// 2</span></span><br><span class="line">                    map(l -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date())), </span><br><span class="line">            String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>MediaType.TEXT_EVENT_STREAM</code>表示<code>Content-Type</code>为<code>text/event-stream</code>，即SSE；</li>
<li>利用interval生成每秒一个数据的流。</li>
</ol>
<p><strong>2）配置router</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">timerRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> route(GET(<span class="string">"/time"</span>), timeHandler::getTime)</span><br><span class="line">            .andRoute(GET(<span class="string">"/date"</span>), timeHandler::getDate)</span><br><span class="line">            .andRoute(GET(<span class="string">"/times"</span>), timeHandler::sendTimePerSec);  <span class="comment">// 增加这一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3）重启服务试一下</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/times</span><br><span class="line">data:21:32:22</span><br><span class="line">data:21:32:23</span><br><span class="line">data:21:32:24</span><br><span class="line">data:21:32:25</span><br><span class="line">data:21:32:26</span><br><span class="line">&lt;Ctrl+C&gt;</span><br></pre></td></tr></table></figure>
<p>就酱，访问这个url会收到持续不断的报时数据（时间数据是在<code>data</code>中的）。</p>
<h3 id="响应式Spring-Data"><a href="#响应式Spring-Data" class="headerlink" title="响应式Spring Data"></a>响应式Spring Data</h3><p>开发基于响应式流的应用，就像是在搭建数据流流动的管道，从而异步的数据能够顺畅流过每个环节。前边的例子主要聚焦于应用层，然而绝大多数系统免不了要与数据库进行交互，所以我们也需要响应式的<strong>持久层API</strong>和<strong>支持异步的数据库驱动</strong>。就像从自来水厂到家里水龙头这个管道中，如果任何一个环节发生了阻塞，那就可能造成整体吞吐量的下降。</p>
<p>各个数据库都开始陆续推出异步驱动，目前Spring Data支持的可以进行响应式数据访问的数据库有MongoDB、Redis、Apache Cassandra和CouchDB。今天我们用MongoDB来写一个响应式demo。</p>
<p>我们这个例子很简单，就是关于<code>User</code>的增删改查，以及基于注解的服务端推送。</p>
<p><strong>1）编写<code>User</code></strong></p>
<p>既然是举例，我们随便定义几个属性吧~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String id;</span><br><span class="line">     <span class="keyword">private</span> String username;</span><br><span class="line">     <span class="keyword">private</span> String phone;</span><br><span class="line">     <span class="keyword">private</span> String email;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> Date birthday;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后为了方便开发，我们引入lombok库，它能够通过注解的方式为我们添加必要的<em>Getter/Setter/hashCode()/equals()/toString()/</em>构造方法等，添加依赖（版本可自行到<a href="http://search.maven.org/" target="_blank" rel="noopener">http://search.maven.org</a>搜索最新）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后为<code>User</code>添加注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   <span class="comment">// 生成无参构造方法/getter/setter/hashCode/equals/toString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">// 生成所有参数构造方法</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">// @AllArgsConstructor会导致@Data不生成无参构造方法，需要手动添加@NoArgsConstructor，如果没有无参构造方法，可能会导致比如com.fasterxml.jackson在序列化处理时报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 可能需要先在IDE中进行少量配置以便支持lombok的注解，比如IntelliJ IDEA：</p>
<ol>
<li>安装“lombok plugin”：settings-Plugins-🔍lombok</li>
<li>开启对注解编译的支持：settings-bulid,Execution,Deployment-Compiler-default-☑️Enable annotation processing</li>
</ol>
</blockquote>
<p><strong>2）增加Spring Data的依赖</strong></p>
<p>在POM中增加Spring Data Reactive Mongo的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MongoDB是文档型的NoSQL数据库，因此，我们使用<code>@Document</code>注解<code>User</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;      <span class="comment">// 注解属性id为ID</span></span><br><span class="line">    <span class="meta">@Indexed</span>(unique = <span class="keyword">true</span>) <span class="comment">// 注解属性username为索引，并且不能重复</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，这样我们的模型就准备好了。MongoDB会自动创建collection，默认为类名首字母小写，也就是<code>user</code>。</p>
<p><strong>3）配置数据源</strong></p>
<p>Spring Boot为我们搞定了几乎所有的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html" target="_blank" rel="noopener">配置</a>，太赞了，下边是MongoDB的默认配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># MONGODB (MongoProperties)</span><br><span class="line">spring.data.mongodb.authentication-database= # Authentication database name.</span><br><span class="line">spring.data.mongodb.database=test # Database name.</span><br><span class="line">spring.data.mongodb.field-naming-strategy= # Fully qualified name of the FieldNamingStrategy to use.</span><br><span class="line">spring.data.mongodb.grid-fs-database= # GridFS database name.</span><br><span class="line">spring.data.mongodb.host=localhost # Mongo server host. Cannot be set with uri.</span><br><span class="line">spring.data.mongodb.password= # Login password of the mongo server. Cannot be set with uri.</span><br><span class="line">spring.data.mongodb.port=27017 # Mongo server port. Cannot be set with uri.</span><br><span class="line">spring.data.mongodb.repositories.enabled=true # Enable Mongo repositories.</span><br><span class="line">spring.data.mongodb.uri=mongodb://localhost/test # Mongo database URI. Cannot be set with host, port and credentials.</span><br><span class="line">spring.data.mongodb.username= # Login user of the mongo server. Cannot be set with uri.</span><br></pre></td></tr></table></figure>
<p>请根据需要添加自定义的配置，比如我的MongoDB是跑在IP为192.168.0.101的虚拟机的Docker中的，就可在<code>application.properties</code>中增加一条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.host=192.168.0.101</span><br></pre></td></tr></table></figure>
<p><strong>4）增加DAO层repository</strong></p>
<p>与非响应式Spring Data的<code>CrudReposity</code>对应的，响应式的Spring Data也提供了相应的Repository库：<code>ReactiveCrudReposity</code>，当然，我们也可以使用它的子接口<code>ReactiveMongoRepository</code>。</p>
<p>我们增加<code>UserRepository</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">ReactiveCrudRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;  <span class="comment">// 1</span></span><br><span class="line">    <span class="function">Mono&lt;User&gt; <span class="title">findByUsername</span><span class="params">(String username)</span></span>;     <span class="comment">// 2</span></span><br><span class="line">    <span class="function">Mono&lt;Long&gt; <span class="title">deleteByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>同样的，<code>ReactiveCrudRepository</code>的泛型分别是<code>User</code>和<code>ID</code>的类型；</li>
<li><code>ReactiveCrudRepository</code>已经提供了基本的增删改查的方法，根据业务需要，我们增加四个方法</li>
</ol>
<p><strong>5）Service层</strong></p>
<p>由于业务逻辑几乎为零，只是简单调用了DAO层，直接贴代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存或更新。</span></span><br><span class="line"><span class="comment">     * 如果传入的user没有id属性，由于username是unique的，在重复的情况下有可能报错，</span></span><br><span class="line"><span class="comment">     * 这时找到以保存的user记录用传入的user更新它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user)</span><br><span class="line">                .onErrorResume(e -&gt;     <span class="comment">// 1</span></span><br><span class="line">                        userRepository.findByUsername(user.getUsername())   <span class="comment">// 2</span></span><br><span class="line">                                .flatMap(originalUser -&gt; &#123;      <span class="comment">// 4</span></span><br><span class="line">                                    user.setId(originalUser.getId());</span><br><span class="line">                                    <span class="keyword">return</span> userRepository.save(user);   <span class="comment">// 3</span></span><br><span class="line">                                &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Long&gt; <span class="title">deleteByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.deleteByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>onErrorResume</code>进行错误处理；</li>
<li>找到username重复的记录；</li>
<li>拿到ID从而进行更新而不是创建；</li>
<li>由于函数式为<code>User -&gt; Publisher</code>，所以用<code>flatMap</code>。</li>
</ol>
<p><strong>6）Controller层</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">""</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;username&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Long&gt; <span class="title">deleteByUsername</span><span class="params">(@PathVariable String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.deleteByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;username&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">findByUsername</span><span class="params">(@PathVariable String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>8）stream+json</strong></p>
<p>看到这里细心的朋友可能会有点嘀咕，怎么看是不是异步的呢？毕竟查询全部的时候，结果都用中括号括起来了，这和原来返回<code>List&lt;User&gt;</code>的效果似乎没多大区别。假设一下查询100个数据，如果是异步的话，以我们对“异步响应式流”的印象似乎应该是一个一个至少是一批一批的到达客户端的嘛。我们加个延迟验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userService.findAll().delayElements(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个元素都延迟1秒，现在我们在数据库里弄三条记录，然后请求查询全部的那个URL，发现并不是像<code>/times</code>一样一秒一个地出来，而是3秒之后一块儿出来的。果然如此，这一点都不响应式啊！</p>
<p>与<code>/times</code>类似，我们也加一个MediaType，不过由于这里返回的是JSON，因此不能使用<code>TEXT_EVENT_STREAM</code>，而是使用<code>APPLICATION_STREAM_JSON</code>，即<code>application/stream+json</code>格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">""</span>, produces = MediaType.APPLICATION_STREAM_JSON_VALUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userService.findAll().delayElements(Duration.ofSeconds(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>produces</code>后边的值应该是<code>application/stream+json</code>字符串，因此用<code>APPLICATION_STREAM_JSON_VALUE</code>。</p>
</blockquote>
<p>重启服务再次请求，发现三个user是一秒一个的速度出来的，中括号也没有了，而是一个一个独立的JSON值构成的json stream：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"5a9504a167646d057051e229"</span>,<span class="attr">"username"</span>:<span class="string">"zhangsan"</span>,<span class="attr">"name"</span>:<span class="string">"张三"</span>,<span class="attr">"phone"</span>:<span class="string">"18610861861"</span>,<span class="attr">"birthday"</span>:<span class="string">"1989-12-31T16:00:00.000+0000"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"5a9511db67646d3c782f2e7f"</span>,<span class="attr">"username"</span>:<span class="string">"lisi"</span>,<span class="attr">"name"</span>:<span class="string">"李四"</span>,<span class="attr">"phone"</span>:<span class="string">"18610861862"</span>,<span class="attr">"birthday"</span>:<span class="string">"1992-02-01T16:00:00.000+0000"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"5a955f08fa10b93ec48df37f"</span>,<span class="attr">"username"</span>:<span class="string">"wangwu"</span>,<span class="attr">"name"</span>:<span class="string">"王五"</span>,<span class="attr">"phone"</span>:<span class="string">"18610861865"</span>,<span class="attr">"birthday"</span>:<span class="string">"1995-05-04T16:00:00.000+0000"</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>9）总结</strong></p>
<p>如果有Spring Data开发经验的话，切换到Spring Data Reactive的难度并不高。跟Spring WebFlux类似：原来返回<code>User</code>的话，那现在就返回<code>Mono</code>；原来返回<code>List</code>的话，那现在就返回<code>Flux</code>。</p>
<p>对于稍微复杂的业务逻辑或一些必要的异常处理，比如上边的save方法，请一定采用响应式的编程方式来定义，从而一切都是异步非阻塞的。如下图所示，从HttpServer（如Netty或Servlet3.1以上的Servlet容器）到ServerAdapter（Spring WebFlux框架提供的针对不同server的适配器），到我们编写的Controller和DAO，以及异步数据库驱动，构成了一个完整的异步非阻塞的管道，里边流动的就是响应式流。</p>
<p><img src="images/image-20200528164804774.png" alt="image-20200528164804774"></p>
<h3 id="使用WebClient开发响应式Http客户端"><a href="#使用WebClient开发响应式Http客户端" class="headerlink" title="使用WebClient开发响应式Http客户端"></a>使用<code>WebClient</code>开发响应式Http客户端</h3><p>下面，我们用WebClient测试一下前边几个例子的成果。</p>
<p><strong>1)  /hello，返回Mono</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webClientTest1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    WebClient webClient = WebClient.create(<span class="string">"http://localhost:8080"</span>);   <span class="comment">// 1</span></span><br><span class="line">    Mono&lt;String&gt; resp = webClient</span><br><span class="line">            .get().uri(<span class="string">"/hello"</span>) <span class="comment">// 2</span></span><br><span class="line">            .retrieve() <span class="comment">// 3</span></span><br><span class="line">            .bodyToMono(String.class);  <span class="comment">// 4</span></span><br><span class="line">    resp.subscribe(System.out::println);    <span class="comment">// 5</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建<code>WebClient</code>对象并指定baseUrl；</li>
<li>HTTP GET；</li>
<li>异步地获取response信息；</li>
<li>将response body解析为字符串；</li>
<li>打印出来；</li>
<li>由于是异步的，我们将测试线程sleep 1秒确保拿到response，也可以像前边的例子一样用<code>CountDownLatch</code>。</li>
</ol>
<p><strong>2） /user，返回Flux</strong></p>
<p>为了多演示一些不同的实现方式，下边的例子我们调整几个地方，但是效果跟上边是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webClientTest2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    WebClient webClient = WebClient.builder().baseUrl(<span class="string">"http://localhost:8080"</span>).build(); <span class="comment">// 1</span></span><br><span class="line">    webClient</span><br><span class="line">            .get().uri(<span class="string">"/user"</span>)</span><br><span class="line">            .accept(MediaType.APPLICATION_STREAM_JSON) <span class="comment">// 2</span></span><br><span class="line">            .exchange() <span class="comment">// 3</span></span><br><span class="line">            .flatMapMany(response -&gt; response.bodyToFlux(User.class))   <span class="comment">// 4</span></span><br><span class="line">            .doOnNext(System.out::println)  <span class="comment">// 5</span></span><br><span class="line">            .blockLast();   <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这次我们使用WebClientBuilder来构建WebClient对象；</li>
<li>配置请求Header：<code>Content-Type: application/stream+json</code>；</li>
<li>获取response信息，返回值为<code>ClientResponse</code>，<code>retrive()</code>可以看做是<code>exchange()</code>方法的“快捷版”；</li>
<li>使用<code>flatMap</code>来将ClientResponse映射为Flux；</li>
<li>只读地peek每个元素，然后打印出来，它并不是subscribe，所以不会触发流；</li>
<li>上个例子中sleep的方式有点low，<code>blockLast</code>方法，顾名思义，在收到最后一个元素前会阻塞，响应式业务场景中慎用。</li>
</ol>
<p><strong>3） /times，服务端推送</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webClientTest3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    WebClient webClient = WebClient.create(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line">    webClient</span><br><span class="line">            .get().uri(<span class="string">"/times"</span>)</span><br><span class="line">            .accept(MediaType.TEXT_EVENT_STREAM)    <span class="comment">// 1</span></span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToFlux(String.class)</span><br><span class="line">            .log()  <span class="comment">// 2</span></span><br><span class="line">            .take(<span class="number">10</span>)   <span class="comment">// 3</span></span><br><span class="line">            .blockLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>配置请求Header：<code>Content-Type: text/event-stream</code>，即SSE；</li>
<li>这次用<code>log()</code>代替<code>doOnNext(System.out::println)</code>来查看每个元素；</li>
<li>由于<code>/times</code>是一个无限流，这里取前10个，会导致流<strong>被取消</strong>；</li>
</ol>
<h3 id="让数据在Http上双向无限流动起来"><a href="#让数据在Http上双向无限流动起来" class="headerlink" title="让数据在Http上双向无限流动起来"></a>让数据在Http上双向无限流动起来</h3><p>🔧下面我们实现一个这样两个Endpoint：</p>
<ul>
<li>POST方法的<code>/events</code>，“源源不断”地收集数据，并存入数据库；</li>
<li>GET方法的<code>/events</code>，“源源不断”将数据库中的记录发出来。</li>
</ul>
<p><strong>0）准备</strong></p>
<p>一、数据模型MyEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"event"</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>指定collection名为<code>event</code>；</li>
<li>这次我们使用表示时间的long型数据作为ID。</li>
</ol>
<p>二、DAO层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyEventRepository</span> <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">MyEvent</span>, <span class="title">Long</span>&gt; </span>&#123; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下边用到了可以保存Flux的<code>insert(Flux)</code>方法，这个方法是在<code>ReactiveMongoRepository</code>中定义的。</p>
</blockquote>
<p>三、简单起见就不要Service层了，直接Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/events"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyEventRepository myEventRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(path = <span class="string">""</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">loadEvents</span><span class="params">(@RequestBody Flux&lt;MyEvent&gt; events)</span> </span>&#123;   <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">""</span>, produces = MediaType.APPLICATION_STREAM_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;MyEvent&gt; <span class="title">getEvents</span><span class="params">()</span> </span>&#123;  <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>POST方法的接收数据流的<code>Endpoint</code>，所以传入的参数是一个Flux，返回结果其实就看需要了，我们用一个<code>Mono</code>作为方法返回值，表示如果传输完的话只给一个“完成信号”就OK了；</li>
<li>GET方法的无限发出数据流的Endpoint，所以返回结果是一个<code>Flux&lt;MyEvent&gt;</code>，不要忘了注解上<code>produces = MediaType.APPLICATION_STREAM_JSON_VALUE</code>。</li>
</ol>
<p><strong>1）接收数据流的Endpoint</strong></p>
<p>在客户端，<code>WebClient</code>可以接收<code>text/event-stream</code>和<code>application/stream+json</code>格式的数据流，也可以在请求的时候上传一个数据流到服务器；<br>在服务端，WebFlux也支持接收一个数据流作为请求参数，从而实现一个接收数据流的Endpoint。</p>
<p>我们先看服务端。Controller中的<code>loadEvents</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">""</span>, consumes = MediaType.APPLICATION_STREAM_JSON_VALUE) <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">loadEvents</span><span class="params">(@RequestBody Flux&lt;MyEvent&gt; events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.myEventRepository.insert(events).then();    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>指定传入的数据是<code>application/stream+json</code>，与<code>getEvents</code>方法的区别在于这个方法是<code>consume</code>这个数据流；</li>
<li><code>insert</code>返回的是保存成功的记录的Flux，但我们不需要，使用<code>then</code>方法表示“忽略数据元素，只返回一个完成信号。</li>
</ol>
<p>服务端写好后，启动之，再看一下客户端怎么写（还是放在<code>src/test</code>下）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webClientTest4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Flux&lt;MyEvent&gt; eventFlux = Flux.interval(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">            .map(l -&gt; <span class="keyword">new</span> MyEvent(System.currentTimeMillis(), <span class="string">"message-"</span> + l)).take(<span class="number">5</span>); <span class="comment">// 1</span></span><br><span class="line">    WebClient webClient = WebClient.create(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line">    webClient</span><br><span class="line">            .post().uri(<span class="string">"/events"</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_STREAM_JSON) <span class="comment">// 2</span></span><br><span class="line">            .body(eventFlux, MyEvent.class) <span class="comment">// 3</span></span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Void.class)</span><br><span class="line">            .block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>声明速度为每秒一个MyEvent元素的数据流，不加<code>take</code>的话表示无限个元素的数据流；</li>
<li>声明请求体的数据格式为<code>application/stream+json</code>；</li>
<li><code>body</code>方法设置请求体的数据。</li>
</ol>
<p>运行一下这个测试，根据控制台数据可以看到是一条一条将数据发到<code>/events</code>的，看一下MongoDB中的数据：</p>
<p><img src="images/image-20200528171159505.png" alt="image-20200528171159505"></p>
<p><strong>2）发出无限流的Endpoint</strong></p>
<p>回想一下前边<code>/user</code>的例子，当数据库中所有的内容都查询出来之后，这个流就结束了，因为其后跟了一个“完成信号”，我们可以通过在<code>UserService</code>的<code>findAll()</code>方法的流上增加<code>log()</code>操作符来观察更详细的日志：</p>
<p><img src="images/image-20200528171236497.png" alt="image-20200528171236497"></p>
<p>我们可以看到在三个<code>onNext</code>信号后是一个<code>onComplete</code>信号。</p>
<p>这样的流是有限流，这个时候如果在数据库中再新增一个User的话，已经结束的请求也不会再有新的内容出现了。</p>
<p>反观<code>/times</code>请求，它会无限地发出SSE，而不会有“完成信号”出现，这是无限流。</p>
<p>我们希望的情况是无论是请求GET的<code>/events</code>之后，当所有数据都发完之后，不要结束，而是挂起等待新的数据。如果我们用上边的POST的<code>/events</code>传入新的数据到数据库后，新的数据会自动地流到客户端。</p>
<p>这可以在DAO层配置实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyEventRepository</span> <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">MyEvent</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Tailable</span>   <span class="comment">// 1</span></span><br><span class="line">    <span class="function">Flux&lt;MyEvent&gt; <span class="title">findBy</span><span class="params">()</span></span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>@Tailable</code>注解的作用类似于linux的<code>tail</code>命令，被注解的方法将发送无限流，需要注解在返回值为Flux这样的多个元素的Publisher的方法上</li>
<li><code>findAll()</code>是想要的方法，但是在ReactiveMongoRepository中我们够不着，所以使用<code>findBy()</code>代替。</li>
</ol>
<p>然后完成Controller中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">""</span>, produces = MediaType.APPLICATION_STREAM_JSON_VALUE)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Flux&lt;MyEvent&gt; <span class="title">getEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.myEventRepository.findBy();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>不过，这还不够，<code>@Tailable</code>仅支持有大小限制的（“capped”）collection，而自动创建的collection是不限制大小的，因此我们需要先手动创建。Spring Boot提供的<code>CommandLineRunner</code>可以帮助我们实现这一点。</p>
<p>Spring Boot应用程序在启动后，会遍历CommandLineRunner接口的实例并运行它们的run方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>   <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">initData</span><span class="params">(MongoOperations mongo)</span> </span>&#123;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> (String... args) -&gt; &#123;    <span class="comment">// 3</span></span><br><span class="line">        mongo.dropCollection(MyEvent.class);    <span class="comment">// 4</span></span><br><span class="line">        mongo.createCollection(MyEvent.class, CollectionOptions.empty().size(<span class="number">200</span>).capped()); <span class="comment">// 5</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>对于复杂的Bean只能通过Java Config的方式配置，这也是为什么Spring3之后官方推荐这种配置方式的原因，这段代码可以放到配置类中，本例我们就直接放到启动类<code>WebFluxDemoApplication</code>了；</li>
<li><code>MongoOperations</code>提供对MongoDB的操作方法，由Spring注入的mongo实例已经配置好，直接使用即可；</li>
<li><code>CommandLineRunner</code>也是一个函数式接口，其实例可以用lambda表达；</li>
<li>如果有，先删除collection，生产环境慎用这种操作；</li>
<li>创建一个记录个数为10的capped的collection，容量满了之后，新增的记录会覆盖最旧的。</li>
</ol>
<p>OK，这个时候我们请求一下<code>http://localhost:8080/events</code>，发现立马返回了，并没有挂起。原因在于collection中一条记录都没有，而<code>@Tailable</code>起作用的前提是至少有一条记录。</p>
<p>跑一下WebClient测试程序插入5条数据，然后再次请求</p>
<p><img src="../../../../../Downloads/typora笔记/images/image-20200528174106393.png" alt="image-20200528174106393"></p>
<p>请求是挂起的，这没错，但是只有两条数据，看WebClient测试程序的控制台明明发出了5个请求啊。</p>
<p>原因定义的<code>CollectionOptions.empty().size(200).capped()</code>中，size指的是以字节为单位的大小，并且会向上取到256的整倍数，所以我们刚才定义的是256byte大小的collection，所以最多容纳两条记录。我们可以这样改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CollectionOptions.empty().maxDocuments(<span class="number">200</span>).size(<span class="number">100000</span>).capped()</span><br></pre></td></tr></table></figure>
<p><code>maxDocuments</code>限制了记录条数，<code>size</code>限制容量且是必须定义的，因为MongoDB不像关系型数据库有严格的列和字段大小定义，鬼知道会存多大的数据进来，所以容量限制是必要的。</p>
<p>好了，再次启动应用，先插入5条数据，然后请求<code>/events</code>，收到5条记录后请求仍然挂起，在插入5条数据，curl客户端又会陆续收到新的数据。</p>
<p><img src="images/image-20200528174245077.png" alt="image-20200528174245077"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这一节，我们对WebFlux做了一个简单的基于实例的介绍，相信你对响应式编程及其在WEB应用中如何发挥作用有了更多的体会，本章的实战是比较基础的，初衷是希望能够通过上手编写代码体会响应式编程的感觉，因为切换到响应式思维方式并非易事。</p>
<p>这一章的核心关键词其实翻来覆去就是：“异步非阻塞的响应式流”。我们了解了异步非阻塞的好处，也知道如何让数据流动起来，下面我们就通过对实例的性能测试，借助实实在在的数据，真切感受一下异步非阻塞的“丝滑”。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/05/java-8/" rel="next" title="Java8新特性">
                <i class="fa fa-chevron-left"></i> Java8新特性
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/12/machine-learning/" rel="prev" title="通过MNIST场景实现理解机器学习">
                通过MNIST场景实现理解机器学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Iwhale" />
          <p class="site-author-name" itemprop="name">Iwhale</p>
          <p class="site-description motion-element" itemprop="description">Dream, Such as whales to the sea.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/flyEn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005055406757796/home" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring5之使用Spring-WebFlux开发响应式应用"><span class="nav-number">1.</span> <span class="nav-text">Spring5之使用Spring WebFlux开发响应式应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor-3-响应式编程库"><span class="nav-number">1.1.</span> <span class="nav-text">Reactor 3 响应式编程库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flux和Mono"><span class="nav-number">1.1.1.</span> <span class="nav-text">Flux和Mono</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#订阅前什么都不会发生"><span class="nav-number">1.1.2.</span> <span class="nav-text">订阅前什么都不会发生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试与调试"><span class="nav-number">1.1.3.</span> <span class="nav-text">测试与调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符（Operator）"><span class="nav-number">1.1.4.</span> <span class="nav-text">操作符（Operator）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）map-元素映射为新元素"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1）map-元素映射为新元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）flatMap-元素映射成流"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">2）flatMap-元素映射成流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3）filter-过滤"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">3）filter-过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4）zip-一对一合并"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">4）zip-一对一合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5）更多"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">5）更多</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度器与线程模型"><span class="nav-number">1.1.5.</span> <span class="nav-text">调度器与线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误处理"><span class="nav-number">1.1.6.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-捕获并返回一个静态的缺省值。"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">1. 捕获并返回一个静态的缺省值。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-捕获并执行一个异常处理方法或计算一个候补值来顶替"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">2. 捕获并执行一个异常处理方法或计算一个候补值来顶替</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-捕获，并再包装为某一个业务相关的异常，然后再抛出业务异常"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">3. 捕获，并再包装为某一个业务相关的异常，然后再抛出业务异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-捕获，记录错误日志，然后继续抛出"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">4. 捕获，记录错误日志，然后继续抛出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-使用-finally-来清理资源，或使用-Java-7-引入的-“try-with-resource”"><span class="nav-number">1.1.6.5.</span> <span class="nav-text">5. 使用 finally 来清理资源，或使用 Java 7 引入的 “try-with-resource”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重试"><span class="nav-number">1.1.6.6.</span> <span class="nav-text">重试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回压"><span class="nav-number">1.1.7.</span> <span class="nav-text">回压</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.1.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-WebFlux"><span class="nav-number">1.2.</span> <span class="nav-text">Spring WebFlux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于WebMVC注解的方式"><span class="nav-number">1.2.1.</span> <span class="nav-text">基于WebMVC注解的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebFlux的函数式开发模式"><span class="nav-number">1.2.2.</span> <span class="nav-text">WebFlux的函数式开发模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器推送"><span class="nav-number">1.2.3.</span> <span class="nav-text">服务器推送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应式Spring-Data"><span class="nav-number">1.2.4.</span> <span class="nav-text">响应式Spring Data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用WebClient开发响应式Http客户端"><span class="nav-number">1.2.5.</span> <span class="nav-text">使用WebClient开发响应式Http客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让数据在Http上双向无限流动起来"><span class="nav-number">1.2.6.</span> <span class="nav-text">让数据在Http上双向无限流动起来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">1.2.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy;  Thu Jan 05 2017 08:00:00 GMT+0800 (中国标准时间) - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Iwhale</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  




  
  

  

  

  

  


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
<script type="text/javascript" src="//7u2ss1.com1.z0.glb.clouddn.com/love.js"></script>

<a href="https://github.com/flyEn"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/c6625ac1f3ee0a12250227cf83ce904423abf351/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png"></a>
</body>
</html>
